<?php
/**
 * XRechnungConversionApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AVACloud API 1.64.1
 *
 * AVACloud API specification
 *
 * The version of the OpenAPI document: 1.64.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */


/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Dangl\AVACloud\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Dangl\AVACloud\ApiException;
use Dangl\AVACloud\Configuration;
use Dangl\AVACloud\FormDataProcessor;
use Dangl\AVACloud\HeaderSelector;
use Dangl\AVACloud\ObjectSerializer;

/**
 * XRechnungConversionApi Class Doc Comment
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class XRechnungConversionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'xRechnungConversionConvertAvaToPdfInvoice' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'xRechnungConversionConvertAvaToXRechnung' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'xRechnungConversionConvertInvoiceToPdfInvoice' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'xRechnungConversionConvertInvoiceToXRechnung' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'xRechnungConversionConvertXRechnungToAva' => [
            'multipart/form-data',
        ],
        'xRechnungConversionConvertXRechnungToInvoice' => [
            'multipart/form-data',
        ],
        'xRechnungConversionMergeInvoiceIntoPdfFile' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoice
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper avaWrapper (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\Dangl\AVACloud\Model\ApiError
     */
    public function xRechnungConversionConvertAvaToPdfInvoice($avaWrapper, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'][0])
    {
        list($response) = $this->xRechnungConversionConvertAvaToPdfInvoiceWithHttpInfo($avaWrapper, $contentType);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoiceWithHttpInfo
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\Dangl\AVACloud\Model\ApiError, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertAvaToPdfInvoiceWithHttpInfo($avaWrapper, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'][0])
    {
        $request = $this->xRechnungConversionConvertAvaToPdfInvoiceRequest($avaWrapper, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\ApiError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoiceAsync
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToPdfInvoiceAsync($avaWrapper, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'][0])
    {
        return $this->xRechnungConversionConvertAvaToPdfInvoiceAsyncWithHttpInfo($avaWrapper, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoiceAsyncWithHttpInfo
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToPdfInvoiceAsyncWithHttpInfo($avaWrapper, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertAvaToPdfInvoiceRequest($avaWrapper, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertAvaToPdfInvoice'
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function xRechnungConversionConvertAvaToPdfInvoiceRequest($avaWrapper, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToPdfInvoice'][0])
    {

        // verify the required parameter 'avaWrapper' is set
        if ($avaWrapper === null || (is_array($avaWrapper) && count($avaWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $avaWrapper when calling xRechnungConversionConvertAvaToPdfInvoice'
            );
        }


        $resourcePath = '/conversion/xrechnung/ava-wrapper/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($avaWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($avaWrapper));
            } else {
                $httpBody = $avaWrapper;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnung
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper avaWrapper (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToXRechnung'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\Dangl\AVACloud\Model\ApiError
     */
    public function xRechnungConversionConvertAvaToXRechnung($avaWrapper, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToXRechnung'][0])
    {
        list($response) = $this->xRechnungConversionConvertAvaToXRechnungWithHttpInfo($avaWrapper, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnungWithHttpInfo
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToXRechnung'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\Dangl\AVACloud\Model\ApiError, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertAvaToXRechnungWithHttpInfo($avaWrapper, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToXRechnung'][0])
    {
        $request = $this->xRechnungConversionConvertAvaToXRechnungRequest($avaWrapper, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\ApiError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnungAsync
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToXRechnung'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToXRechnungAsync($avaWrapper, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToXRechnung'][0])
    {
        return $this->xRechnungConversionConvertAvaToXRechnungAsyncWithHttpInfo($avaWrapper, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnungAsyncWithHttpInfo
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToXRechnung'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToXRechnungAsyncWithHttpInfo($avaWrapper, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToXRechnung'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertAvaToXRechnungRequest($avaWrapper, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertAvaToXRechnung'
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $avaWrapper (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertAvaToXRechnung'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function xRechnungConversionConvertAvaToXRechnungRequest($avaWrapper, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertAvaToXRechnung'][0])
    {

        // verify the required parameter 'avaWrapper' is set
        if ($avaWrapper === null || (is_array($avaWrapper) && count($avaWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $avaWrapper when calling xRechnungConversionConvertAvaToXRechnung'
            );
        }





        $resourcePath = '/conversion/xrechnung/ava-wrapper/xrechnung';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $targetFormat,
            'TargetFormat', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disablePriceRounding,
            'DisablePriceRounding', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disableBrandingComment,
            'DisableBrandingComment', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($avaWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($avaWrapper));
            } else {
                $httpBody = $avaWrapper;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoice
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice invoice (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\Dangl\AVACloud\Model\ApiError
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoice($invoice, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'][0])
    {
        list($response) = $this->xRechnungConversionConvertInvoiceToPdfInvoiceWithHttpInfo($invoice, $contentType);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoiceWithHttpInfo
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\Dangl\AVACloud\Model\ApiError, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoiceWithHttpInfo($invoice, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'][0])
    {
        $request = $this->xRechnungConversionConvertInvoiceToPdfInvoiceRequest($invoice, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\ApiError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoiceAsync
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoiceAsync($invoice, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'][0])
    {
        return $this->xRechnungConversionConvertInvoiceToPdfInvoiceAsyncWithHttpInfo($invoice, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoiceAsyncWithHttpInfo
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoiceAsyncWithHttpInfo($invoice, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertInvoiceToPdfInvoiceRequest($invoice, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertInvoiceToPdfInvoice'
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoiceRequest($invoice, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToPdfInvoice'][0])
    {

        // verify the required parameter 'invoice' is set
        if ($invoice === null || (is_array($invoice) && count($invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice when calling xRechnungConversionConvertInvoiceToPdfInvoice'
            );
        }


        $resourcePath = '/conversion/xrechnung/invoice/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice));
            } else {
                $httpBody = $invoice;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnung
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice invoice (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\Dangl\AVACloud\Model\ApiError
     */
    public function xRechnungConversionConvertInvoiceToXRechnung($invoice, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'][0])
    {
        list($response) = $this->xRechnungConversionConvertInvoiceToXRechnungWithHttpInfo($invoice, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnungWithHttpInfo
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\Dangl\AVACloud\Model\ApiError, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertInvoiceToXRechnungWithHttpInfo($invoice, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'][0])
    {
        $request = $this->xRechnungConversionConvertInvoiceToXRechnungRequest($invoice, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\ApiError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnungAsync
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToXRechnungAsync($invoice, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'][0])
    {
        return $this->xRechnungConversionConvertInvoiceToXRechnungAsyncWithHttpInfo($invoice, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnungAsyncWithHttpInfo
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToXRechnungAsyncWithHttpInfo($invoice, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertInvoiceToXRechnungRequest($invoice, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertInvoiceToXRechnung'
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function xRechnungConversionConvertInvoiceToXRechnungRequest($invoice, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionConvertInvoiceToXRechnung'][0])
    {

        // verify the required parameter 'invoice' is set
        if ($invoice === null || (is_array($invoice) && count($invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice when calling xRechnungConversionConvertInvoiceToXRechnung'
            );
        }





        $resourcePath = '/conversion/xrechnung/invoice/xrechnung';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $targetFormat,
            'TargetFormat', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disablePriceRounding,
            'DisablePriceRounding', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disableBrandingComment,
            'DisableBrandingComment', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice));
            } else {
                $httpBody = $invoice;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAva
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject|null $xrechnungFile xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToAva'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Dangl\AVACloud\Model\AvaProjectWrapper|\Dangl\AVACloud\Model\ApiError
     */
    public function xRechnungConversionConvertXRechnungToAva($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToAva'][0])
    {
        list($response) = $this->xRechnungConversionConvertXRechnungToAvaWithHttpInfo($xrechnungFile, $contentType);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAvaWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToAva'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Dangl\AVACloud\Model\AvaProjectWrapper|\Dangl\AVACloud\Model\ApiError, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertXRechnungToAvaWithHttpInfo($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToAva'][0])
    {
        $request = $this->xRechnungConversionConvertXRechnungToAvaRequest($xrechnungFile, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\AvaProjectWrapper',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\ApiError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Dangl\AVACloud\Model\AvaProjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\AvaProjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAvaAsync
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToAva'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToAvaAsync($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToAva'][0])
    {
        return $this->xRechnungConversionConvertXRechnungToAvaAsyncWithHttpInfo($xrechnungFile, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAvaAsyncWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToAva'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToAvaAsyncWithHttpInfo($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToAva'][0])
    {
        $returnType = '\Dangl\AVACloud\Model\AvaProjectWrapper';
        $request = $this->xRechnungConversionConvertXRechnungToAvaRequest($xrechnungFile, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertXRechnungToAva'
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToAva'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function xRechnungConversionConvertXRechnungToAvaRequest($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToAva'][0])
    {



        $resourcePath = '/conversion/xrechnung/ava-wrapper';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'xrechnungFile' => $xrechnungFile,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoice
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject|null $xrechnungFile xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Dangl\AVACloud\Model\Invoice|\Dangl\AVACloud\Model\ApiError
     */
    public function xRechnungConversionConvertXRechnungToInvoice($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'][0])
    {
        list($response) = $this->xRechnungConversionConvertXRechnungToInvoiceWithHttpInfo($xrechnungFile, $contentType);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoiceWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Dangl\AVACloud\Model\Invoice|\Dangl\AVACloud\Model\ApiError, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertXRechnungToInvoiceWithHttpInfo($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'][0])
    {
        $request = $this->xRechnungConversionConvertXRechnungToInvoiceRequest($xrechnungFile, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\Invoice',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\ApiError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Dangl\AVACloud\Model\Invoice',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoiceAsync
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToInvoiceAsync($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'][0])
    {
        return $this->xRechnungConversionConvertXRechnungToInvoiceAsyncWithHttpInfo($xrechnungFile, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoiceAsyncWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToInvoiceAsyncWithHttpInfo($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'][0])
    {
        $returnType = '\Dangl\AVACloud\Model\Invoice';
        $request = $this->xRechnungConversionConvertXRechnungToInvoiceRequest($xrechnungFile, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertXRechnungToInvoice'
     *
     * @param  \SplFileObject|null $xrechnungFile (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function xRechnungConversionConvertXRechnungToInvoiceRequest($xrechnungFile = null, string $contentType = self::contentTypes['xRechnungConversionConvertXRechnungToInvoice'][0])
    {



        $resourcePath = '/conversion/xrechnung/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'xrechnungFile' => $xrechnungFile,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFile
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdfEmbeddModel pdfEmbeddModel (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\Dangl\AVACloud\Model\ApiError
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFile($pdfEmbeddModel, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'][0])
    {
        list($response) = $this->xRechnungConversionMergeInvoiceIntoPdfFileWithHttpInfo($pdfEmbeddModel, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);
        return $response;
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFileWithHttpInfo
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdfEmbeddModel (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'] to see the possible values for this operation
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\Dangl\AVACloud\Model\ApiError, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFileWithHttpInfo($pdfEmbeddModel, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'][0])
    {
        $request = $this->xRechnungConversionMergeInvoiceIntoPdfFileRequest($pdfEmbeddModel, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\Dangl\AVACloud\Model\ApiError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFileAsync
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdfEmbeddModel (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFileAsync($pdfEmbeddModel, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'][0])
    {
        return $this->xRechnungConversionMergeInvoiceIntoPdfFileAsyncWithHttpInfo($pdfEmbeddModel, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFileAsyncWithHttpInfo
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdfEmbeddModel (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFileAsyncWithHttpInfo($pdfEmbeddModel, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionMergeInvoiceIntoPdfFileRequest($pdfEmbeddModel, $targetFormat, $disablePriceRounding, $disableBrandingComment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionMergeInvoiceIntoPdfFile'
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdfEmbeddModel (required)
     * @param  string|null $targetFormat The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool|null $disablePriceRounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool|null $disableBrandingComment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFileRequest($pdfEmbeddModel, $targetFormat = null, $disablePriceRounding = null, $disableBrandingComment = null, string $contentType = self::contentTypes['xRechnungConversionMergeInvoiceIntoPdfFile'][0])
    {

        // verify the required parameter 'pdfEmbeddModel' is set
        if ($pdfEmbeddModel === null || (is_array($pdfEmbeddModel) && count($pdfEmbeddModel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdfEmbeddModel when calling xRechnungConversionMergeInvoiceIntoPdfFile'
            );
        }





        $resourcePath = '/conversion/xrechnung/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $targetFormat,
            'TargetFormat', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disablePriceRounding,
            'DisablePriceRounding', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disableBrandingComment,
            'DisableBrandingComment', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pdfEmbeddModel)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pdfEmbeddModel));
            } else {
                $httpBody = $pdfEmbeddModel;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
