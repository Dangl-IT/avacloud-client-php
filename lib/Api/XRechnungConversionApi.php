<?php
/**
 * XRechnungConversionApi
 * PHP version 5
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AVACloud API 1.63.6
 *
 * AVACloud API specification
 *
 * OpenAPI spec version: 1.63.6
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.49
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Dangl\AVACloud\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Dangl\AVACloud\ApiException;
use Dangl\AVACloud\Configuration;
use Dangl\AVACloud\HeaderSelector;
use Dangl\AVACloud\ObjectSerializer;

/**
 * XRechnungConversionApi Class Doc Comment
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class XRechnungConversionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoice
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper ava_wrapper (required)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function xRechnungConversionConvertAvaToPdfInvoice($ava_wrapper)
    {
        list($response) = $this->xRechnungConversionConvertAvaToPdfInvoiceWithHttpInfo($ava_wrapper);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoiceWithHttpInfo
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertAvaToPdfInvoiceWithHttpInfo($ava_wrapper)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertAvaToPdfInvoiceRequest($ava_wrapper);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoiceAsync
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToPdfInvoiceAsync($ava_wrapper)
    {
        return $this->xRechnungConversionConvertAvaToPdfInvoiceAsyncWithHttpInfo($ava_wrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertAvaToPdfInvoiceAsyncWithHttpInfo
     *
     * This will convert an AVA wrapper object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToPdfInvoiceAsyncWithHttpInfo($ava_wrapper)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertAvaToPdfInvoiceRequest($ava_wrapper);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertAvaToPdfInvoice'
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function xRechnungConversionConvertAvaToPdfInvoiceRequest($ava_wrapper)
    {
        // verify the required parameter 'ava_wrapper' is set
        if ($ava_wrapper === null || (is_array($ava_wrapper) && count($ava_wrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ava_wrapper when calling xRechnungConversionConvertAvaToPdfInvoice'
            );
        }

        $resourcePath = '/conversion/xrechnung/ava-wrapper/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($ava_wrapper)) {
            $_tempBody = $ava_wrapper;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnung
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper ava_wrapper (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function xRechnungConversionConvertAvaToXRechnung($ava_wrapper, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        list($response) = $this->xRechnungConversionConvertAvaToXRechnungWithHttpInfo($ava_wrapper, $target_format, $disable_price_rounding, $disable_branding_comment);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnungWithHttpInfo
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertAvaToXRechnungWithHttpInfo($ava_wrapper, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertAvaToXRechnungRequest($ava_wrapper, $target_format, $disable_price_rounding, $disable_branding_comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnungAsync
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToXRechnungAsync($ava_wrapper, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        return $this->xRechnungConversionConvertAvaToXRechnungAsyncWithHttpInfo($ava_wrapper, $target_format, $disable_price_rounding, $disable_branding_comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertAvaToXRechnungAsyncWithHttpInfo
     *
     * This will convert an AVA wrapper object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertAvaToXRechnungAsyncWithHttpInfo($ava_wrapper, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertAvaToXRechnungRequest($ava_wrapper, $target_format, $disable_price_rounding, $disable_branding_comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertAvaToXRechnung'
     *
     * @param  \Dangl\AVACloud\Model\AvaProjectWrapper $ava_wrapper (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function xRechnungConversionConvertAvaToXRechnungRequest($ava_wrapper, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        // verify the required parameter 'ava_wrapper' is set
        if ($ava_wrapper === null || (is_array($ava_wrapper) && count($ava_wrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ava_wrapper when calling xRechnungConversionConvertAvaToXRechnung'
            );
        }

        $resourcePath = '/conversion/xrechnung/ava-wrapper/xrechnung';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($target_format !== null) {
            $queryParams['TargetFormat'] = ObjectSerializer::toQueryValue($target_format);
        }
        // query params
        if ($disable_price_rounding !== null) {
            $queryParams['DisablePriceRounding'] = ObjectSerializer::toQueryValue($disable_price_rounding);
        }
        // query params
        if ($disable_branding_comment !== null) {
            $queryParams['DisableBrandingComment'] = ObjectSerializer::toQueryValue($disable_branding_comment);
        }


        // body params
        $_tempBody = null;
        if (isset($ava_wrapper)) {
            $_tempBody = $ava_wrapper;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoice
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice invoice (required)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoice($invoice)
    {
        list($response) = $this->xRechnungConversionConvertInvoiceToPdfInvoiceWithHttpInfo($invoice);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoiceWithHttpInfo
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoiceWithHttpInfo($invoice)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertInvoiceToPdfInvoiceRequest($invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoiceAsync
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoiceAsync($invoice)
    {
        return $this->xRechnungConversionConvertInvoiceToPdfInvoiceAsyncWithHttpInfo($invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToPdfInvoiceAsyncWithHttpInfo
     *
     * This will convert an Invoice object to a PDF file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToPdfInvoiceAsyncWithHttpInfo($invoice)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertInvoiceToPdfInvoiceRequest($invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertInvoiceToPdfInvoice'
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function xRechnungConversionConvertInvoiceToPdfInvoiceRequest($invoice)
    {
        // verify the required parameter 'invoice' is set
        if ($invoice === null || (is_array($invoice) && count($invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice when calling xRechnungConversionConvertInvoiceToPdfInvoice'
            );
        }

        $resourcePath = '/conversion/xrechnung/invoice/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($invoice)) {
            $_tempBody = $invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnung
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice invoice (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function xRechnungConversionConvertInvoiceToXRechnung($invoice, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        list($response) = $this->xRechnungConversionConvertInvoiceToXRechnungWithHttpInfo($invoice, $target_format, $disable_price_rounding, $disable_branding_comment);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnungWithHttpInfo
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertInvoiceToXRechnungWithHttpInfo($invoice, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertInvoiceToXRechnungRequest($invoice, $target_format, $disable_price_rounding, $disable_branding_comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnungAsync
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToXRechnungAsync($invoice, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        return $this->xRechnungConversionConvertInvoiceToXRechnungAsyncWithHttpInfo($invoice, $target_format, $disable_price_rounding, $disable_branding_comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertInvoiceToXRechnungAsyncWithHttpInfo
     *
     * This will convert an Invoice object to an XRechnung file
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertInvoiceToXRechnungAsyncWithHttpInfo($invoice, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionConvertInvoiceToXRechnungRequest($invoice, $target_format, $disable_price_rounding, $disable_branding_comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertInvoiceToXRechnung'
     *
     * @param  \Dangl\AVACloud\Model\Invoice $invoice (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function xRechnungConversionConvertInvoiceToXRechnungRequest($invoice, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        // verify the required parameter 'invoice' is set
        if ($invoice === null || (is_array($invoice) && count($invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice when calling xRechnungConversionConvertInvoiceToXRechnung'
            );
        }

        $resourcePath = '/conversion/xrechnung/invoice/xrechnung';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($target_format !== null) {
            $queryParams['TargetFormat'] = ObjectSerializer::toQueryValue($target_format);
        }
        // query params
        if ($disable_price_rounding !== null) {
            $queryParams['DisablePriceRounding'] = ObjectSerializer::toQueryValue($disable_price_rounding);
        }
        // query params
        if ($disable_branding_comment !== null) {
            $queryParams['DisableBrandingComment'] = ObjectSerializer::toQueryValue($disable_branding_comment);
        }


        // body params
        $_tempBody = null;
        if (isset($invoice)) {
            $_tempBody = $invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAva
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject $xrechnung_file xrechnung_file (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Dangl\AVACloud\Model\AvaProjectWrapper
     */
    public function xRechnungConversionConvertXRechnungToAva($xrechnung_file = null)
    {
        list($response) = $this->xRechnungConversionConvertXRechnungToAvaWithHttpInfo($xrechnung_file);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAvaWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Dangl\AVACloud\Model\AvaProjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertXRechnungToAvaWithHttpInfo($xrechnung_file = null)
    {
        $returnType = '\Dangl\AVACloud\Model\AvaProjectWrapper';
        $request = $this->xRechnungConversionConvertXRechnungToAvaRequest($xrechnung_file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\AvaProjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAvaAsync
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToAvaAsync($xrechnung_file = null)
    {
        return $this->xRechnungConversionConvertXRechnungToAvaAsyncWithHttpInfo($xrechnung_file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToAvaAsyncWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an AVA wrapper object
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToAvaAsyncWithHttpInfo($xrechnung_file = null)
    {
        $returnType = '\Dangl\AVACloud\Model\AvaProjectWrapper';
        $request = $this->xRechnungConversionConvertXRechnungToAvaRequest($xrechnung_file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertXRechnungToAva'
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function xRechnungConversionConvertXRechnungToAvaRequest($xrechnung_file = null)
    {

        $resourcePath = '/conversion/xrechnung/ava-wrapper';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($xrechnung_file !== null) {
            $multipart = true;
            $formParams['xrechnungFile'] = \GuzzleHttp\Psr7\Utils::tryFopen(ObjectSerializer::toFormValue($xrechnung_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoice
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject $xrechnung_file xrechnung_file (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Dangl\AVACloud\Model\Invoice
     */
    public function xRechnungConversionConvertXRechnungToInvoice($xrechnung_file = null)
    {
        list($response) = $this->xRechnungConversionConvertXRechnungToInvoiceWithHttpInfo($xrechnung_file);
        return $response;
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoiceWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Dangl\AVACloud\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionConvertXRechnungToInvoiceWithHttpInfo($xrechnung_file = null)
    {
        $returnType = '\Dangl\AVACloud\Model\Invoice';
        $request = $this->xRechnungConversionConvertXRechnungToInvoiceRequest($xrechnung_file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoiceAsync
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToInvoiceAsync($xrechnung_file = null)
    {
        return $this->xRechnungConversionConvertXRechnungToInvoiceAsyncWithHttpInfo($xrechnung_file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionConvertXRechnungToInvoiceAsyncWithHttpInfo
     *
     * This will read an XRechnung file and convert it to an Invoice object
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionConvertXRechnungToInvoiceAsyncWithHttpInfo($xrechnung_file = null)
    {
        $returnType = '\Dangl\AVACloud\Model\Invoice';
        $request = $this->xRechnungConversionConvertXRechnungToInvoiceRequest($xrechnung_file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionConvertXRechnungToInvoice'
     *
     * @param  \SplFileObject $xrechnung_file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function xRechnungConversionConvertXRechnungToInvoiceRequest($xrechnung_file = null)
    {

        $resourcePath = '/conversion/xrechnung/invoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($xrechnung_file !== null) {
            $multipart = true;
            $formParams['xrechnungFile'] = \GuzzleHttp\Psr7\Utils::tryFopen(ObjectSerializer::toFormValue($xrechnung_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFile
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdf_embedd_model pdf_embedd_model (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFile($pdf_embedd_model, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        list($response) = $this->xRechnungConversionMergeInvoiceIntoPdfFileWithHttpInfo($pdf_embedd_model, $target_format, $disable_price_rounding, $disable_branding_comment);
        return $response;
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFileWithHttpInfo
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdf_embedd_model (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \Dangl\AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFileWithHttpInfo($pdf_embedd_model, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionMergeInvoiceIntoPdfFileRequest($pdf_embedd_model, $target_format, $disable_price_rounding, $disable_branding_comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl\AVACloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFileAsync
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdf_embedd_model (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFileAsync($pdf_embedd_model, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        return $this->xRechnungConversionMergeInvoiceIntoPdfFileAsyncWithHttpInfo($pdf_embedd_model, $target_format, $disable_price_rounding, $disable_branding_comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation xRechnungConversionMergeInvoiceIntoPdfFileAsyncWithHttpInfo
     *
     * This will embedd an XRechnung file into an existing PDF file as an attachment.
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdf_embedd_model (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function xRechnungConversionMergeInvoiceIntoPdfFileAsyncWithHttpInfo($pdf_embedd_model, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->xRechnungConversionMergeInvoiceIntoPdfFileRequest($pdf_embedd_model, $target_format, $disable_price_rounding, $disable_branding_comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'xRechnungConversionMergeInvoiceIntoPdfFile'
     *
     * @param  \Dangl\AVACloud\Model\PostXRechnungPdfEmbedd $pdf_embedd_model (required)
     * @param  string $target_format The target format for the XRechnung export. Defaults to Ubl. Options are: Ubl, CrossIndustryInvoice and FacturX (ZUGFerd) (optional)
     * @param  bool $disable_price_rounding If this is enabled, then the price values in the XRechnung export will not be rounded. Otherwise, prices will by default be rounded to two decimal places. (optional)
     * @param  bool $disable_branding_comment If this is set to true, exported XRechnung files will not contain an XML comment indicating their origin. This is false by default, meaning the comment will be included. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function xRechnungConversionMergeInvoiceIntoPdfFileRequest($pdf_embedd_model, $target_format = null, $disable_price_rounding = null, $disable_branding_comment = null)
    {
        // verify the required parameter 'pdf_embedd_model' is set
        if ($pdf_embedd_model === null || (is_array($pdf_embedd_model) && count($pdf_embedd_model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_embedd_model when calling xRechnungConversionMergeInvoiceIntoPdfFile'
            );
        }

        $resourcePath = '/conversion/xrechnung/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($target_format !== null) {
            $queryParams['TargetFormat'] = ObjectSerializer::toQueryValue($target_format);
        }
        // query params
        if ($disable_price_rounding !== null) {
            $queryParams['DisablePriceRounding'] = ObjectSerializer::toQueryValue($disable_price_rounding);
        }
        // query params
        if ($disable_branding_comment !== null) {
            $queryParams['DisableBrandingComment'] = ObjectSerializer::toQueryValue($disable_branding_comment);
        }


        // body params
        $_tempBody = null;
        if (isset($pdf_embedd_model)) {
            $_tempBody = $pdf_embedd_model;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json', 'application/problem+json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
