<?php
/**
 * RebConversionApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AVACloud API 1.9.1
 *
 * AVACloud API specification
 *
 * OpenAPI spec version: 1.9.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * RebConversionApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RebConversionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation rebConversionConvertToAva
     *
     * Converts REB files to Dangl.AVA projects
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProjectDto
     */
    public function rebConversionConvertToAva($reb_file = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        list($response) = $this->rebConversionConvertToAvaWithHttpInfo($reb_file, $remove_plain_text_long_texts, $remove_html_long_texts);
        return $response;
    }

    /**
     * Operation rebConversionConvertToAvaWithHttpInfo
     *
     * Converts REB files to Dangl.AVA projects
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProjectDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function rebConversionConvertToAvaWithHttpInfo($reb_file = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        $returnType = '\Swagger\Client\Model\ProjectDto';
        $request = $this->rebConversionConvertToAvaRequest($reb_file, $remove_plain_text_long_texts, $remove_html_long_texts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProjectDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rebConversionConvertToAvaAsync
     *
     * Converts REB files to Dangl.AVA projects
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToAvaAsync($reb_file = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        return $this->rebConversionConvertToAvaAsyncWithHttpInfo($reb_file, $remove_plain_text_long_texts, $remove_html_long_texts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rebConversionConvertToAvaAsyncWithHttpInfo
     *
     * Converts REB files to Dangl.AVA projects
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToAvaAsyncWithHttpInfo($reb_file = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        $returnType = '\Swagger\Client\Model\ProjectDto';
        $request = $this->rebConversionConvertToAvaRequest($reb_file, $remove_plain_text_long_texts, $remove_html_long_texts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rebConversionConvertToAva'
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rebConversionConvertToAvaRequest($reb_file = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {

        $resourcePath = '/conversion/reb/ava';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($remove_plain_text_long_texts !== null) {
            $queryParams['RemovePlainTextLongTexts'] = ObjectSerializer::toQueryValue($remove_plain_text_long_texts);
        }
        // query params
        if ($remove_html_long_texts !== null) {
            $queryParams['RemoveHtmlLongTexts'] = ObjectSerializer::toQueryValue($remove_html_long_texts);
        }


        // form params
        if ($reb_file !== null) {
            $multipart = true;
            $formParams['rebFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($reb_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/vnd.com.dangl-it.ProjectDto.v1+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/vnd.com.dangl-it.ProjectDto.v1+json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rebConversionConvertToExcel
     *
     * Converts REB files to Excel
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function rebConversionConvertToExcel($reb_file = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        list($response) = $this->rebConversionConvertToExcelWithHttpInfo($reb_file, $write_prices, $write_long_texts, $conversion_culture);
        return $response;
    }

    /**
     * Operation rebConversionConvertToExcelWithHttpInfo
     *
     * Converts REB files to Excel
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function rebConversionConvertToExcelWithHttpInfo($reb_file = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->rebConversionConvertToExcelRequest($reb_file, $write_prices, $write_long_texts, $conversion_culture);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rebConversionConvertToExcelAsync
     *
     * Converts REB files to Excel
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToExcelAsync($reb_file = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        return $this->rebConversionConvertToExcelAsyncWithHttpInfo($reb_file, $write_prices, $write_long_texts, $conversion_culture)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rebConversionConvertToExcelAsyncWithHttpInfo
     *
     * Converts REB files to Excel
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToExcelAsyncWithHttpInfo($reb_file = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->rebConversionConvertToExcelRequest($reb_file, $write_prices, $write_long_texts, $conversion_culture);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rebConversionConvertToExcel'
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rebConversionConvertToExcelRequest($reb_file = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {

        $resourcePath = '/conversion/reb/excel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($write_prices !== null) {
            $queryParams['WritePrices'] = ObjectSerializer::toQueryValue($write_prices);
        }
        // query params
        if ($write_long_texts !== null) {
            $queryParams['WriteLongTexts'] = ObjectSerializer::toQueryValue($write_long_texts);
        }
        // query params
        if ($conversion_culture !== null) {
            $queryParams['ConversionCulture'] = ObjectSerializer::toQueryValue($conversion_culture);
        }


        // form params
        if ($reb_file !== null) {
            $multipart = true;
            $formParams['rebFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($reb_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rebConversionConvertToGaeb
     *
     * Converts REB files to GAEB files
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function rebConversionConvertToGaeb($reb_file = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        list($response) = $this->rebConversionConvertToGaebWithHttpInfo($reb_file, $destination_gaeb_type, $target_exchange_phase_transform);
        return $response;
    }

    /**
     * Operation rebConversionConvertToGaebWithHttpInfo
     *
     * Converts REB files to GAEB files
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function rebConversionConvertToGaebWithHttpInfo($reb_file = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->rebConversionConvertToGaebRequest($reb_file, $destination_gaeb_type, $target_exchange_phase_transform);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rebConversionConvertToGaebAsync
     *
     * Converts REB files to GAEB files
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToGaebAsync($reb_file = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        return $this->rebConversionConvertToGaebAsyncWithHttpInfo($reb_file, $destination_gaeb_type, $target_exchange_phase_transform)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rebConversionConvertToGaebAsyncWithHttpInfo
     *
     * Converts REB files to GAEB files
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToGaebAsyncWithHttpInfo($reb_file = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->rebConversionConvertToGaebRequest($reb_file, $destination_gaeb_type, $target_exchange_phase_transform);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rebConversionConvertToGaeb'
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rebConversionConvertToGaebRequest($reb_file = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {

        $resourcePath = '/conversion/reb/gaeb';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($destination_gaeb_type !== null) {
            $queryParams['DestinationGaebType'] = ObjectSerializer::toQueryValue($destination_gaeb_type);
        }
        // query params
        if ($target_exchange_phase_transform !== null) {
            $queryParams['TargetExchangePhaseTransform'] = ObjectSerializer::toQueryValue($target_exchange_phase_transform);
        }


        // form params
        if ($reb_file !== null) {
            $multipart = true;
            $formParams['rebFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($reb_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rebConversionConvertToOenorm
     *
     * Converts REB files to Oenorm
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function rebConversionConvertToOenorm($reb_file = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        list($response) = $this->rebConversionConvertToOenormWithHttpInfo($reb_file, $destination_oenorm_type, $try_repair_project_structure);
        return $response;
    }

    /**
     * Operation rebConversionConvertToOenormWithHttpInfo
     *
     * Converts REB files to Oenorm
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function rebConversionConvertToOenormWithHttpInfo($reb_file = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->rebConversionConvertToOenormRequest($reb_file, $destination_oenorm_type, $try_repair_project_structure);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rebConversionConvertToOenormAsync
     *
     * Converts REB files to Oenorm
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToOenormAsync($reb_file = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        return $this->rebConversionConvertToOenormAsyncWithHttpInfo($reb_file, $destination_oenorm_type, $try_repair_project_structure)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rebConversionConvertToOenormAsyncWithHttpInfo
     *
     * Converts REB files to Oenorm
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebConversionConvertToOenormAsyncWithHttpInfo($reb_file = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->rebConversionConvertToOenormRequest($reb_file, $destination_oenorm_type, $try_repair_project_structure);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rebConversionConvertToOenorm'
     *
     * @param  \SplFileObject $reb_file The input file (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rebConversionConvertToOenormRequest($reb_file = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {

        $resourcePath = '/conversion/reb/oenorm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($destination_oenorm_type !== null) {
            $queryParams['DestinationOenormType'] = ObjectSerializer::toQueryValue($destination_oenorm_type);
        }
        // query params
        if ($try_repair_project_structure !== null) {
            $queryParams['TryRepairProjectStructure'] = ObjectSerializer::toQueryValue($try_repair_project_structure);
        }


        // form params
        if ($reb_file !== null) {
            $multipart = true;
            $formParams['rebFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($reb_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
