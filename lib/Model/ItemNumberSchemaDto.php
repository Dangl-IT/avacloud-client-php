<?php
/**
 * ItemNumberSchemaDto
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AVACloud API 1.64.1
 *
 * AVACloud API specification
 *
 * The version of the OpenAPI document: 1.64.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */


/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Dangl\AVACloud\Model;

use \ArrayAccess;
use \Dangl\AVACloud\ObjectSerializer;

/**
 * ItemNumberSchemaDto Class Doc Comment
 *
 * @category Class
 * @description The schema for ItemNumber&#39;s in a Project.
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ItemNumberSchemaDto implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ItemNumberSchemaDto';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'total_length' => 'int',
        'tiers' => '\Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]',
        'separator' => 'string',
        'filler' => 'string',
        'identifier' => 'string',
        'skip_non_existing_levels_in_position_item_numbers' => 'bool',
        'skipped_tiers_filler' => 'string',
        'schema_is_correctly_defined' => 'bool',
        'allow_upper_case_lettering' => 'bool',
        'disable_left_padding_tiers_with_filler' => 'bool',
        'disable_item_number_identifier_transformations' => 'bool',
        'disable_item_number_identifier_transformations_only_for_alphanumeric_tiers' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'total_length' => 'int32',
        'tiers' => null,
        'separator' => null,
        'filler' => null,
        'identifier' => null,
        'skip_non_existing_levels_in_position_item_numbers' => null,
        'skipped_tiers_filler' => null,
        'schema_is_correctly_defined' => null,
        'allow_upper_case_lettering' => null,
        'disable_left_padding_tiers_with_filler' => null,
        'disable_item_number_identifier_transformations' => null,
        'disable_item_number_identifier_transformations_only_for_alphanumeric_tiers' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'total_length' => false,
        'tiers' => false,
        'separator' => false,
        'filler' => false,
        'identifier' => false,
        'skip_non_existing_levels_in_position_item_numbers' => false,
        'skipped_tiers_filler' => false,
        'schema_is_correctly_defined' => false,
        'allow_upper_case_lettering' => false,
        'disable_left_padding_tiers_with_filler' => false,
        'disable_item_number_identifier_transformations' => false,
        'disable_item_number_identifier_transformations_only_for_alphanumeric_tiers' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'total_length' => 'totalLength',
        'tiers' => 'tiers',
        'separator' => 'separator',
        'filler' => 'filler',
        'identifier' => 'identifier',
        'skip_non_existing_levels_in_position_item_numbers' => 'skipNonExistingLevelsInPositionItemNumbers',
        'skipped_tiers_filler' => 'skippedTiersFiller',
        'schema_is_correctly_defined' => 'schemaIsCorrectlyDefined',
        'allow_upper_case_lettering' => 'allowUpperCaseLettering',
        'disable_left_padding_tiers_with_filler' => 'disableLeftPaddingTiersWithFiller',
        'disable_item_number_identifier_transformations' => 'disableItemNumberIdentifierTransformations',
        'disable_item_number_identifier_transformations_only_for_alphanumeric_tiers' => 'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'total_length' => 'setTotalLength',
        'tiers' => 'setTiers',
        'separator' => 'setSeparator',
        'filler' => 'setFiller',
        'identifier' => 'setIdentifier',
        'skip_non_existing_levels_in_position_item_numbers' => 'setSkipNonExistingLevelsInPositionItemNumbers',
        'skipped_tiers_filler' => 'setSkippedTiersFiller',
        'schema_is_correctly_defined' => 'setSchemaIsCorrectlyDefined',
        'allow_upper_case_lettering' => 'setAllowUpperCaseLettering',
        'disable_left_padding_tiers_with_filler' => 'setDisableLeftPaddingTiersWithFiller',
        'disable_item_number_identifier_transformations' => 'setDisableItemNumberIdentifierTransformations',
        'disable_item_number_identifier_transformations_only_for_alphanumeric_tiers' => 'setDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'total_length' => 'getTotalLength',
        'tiers' => 'getTiers',
        'separator' => 'getSeparator',
        'filler' => 'getFiller',
        'identifier' => 'getIdentifier',
        'skip_non_existing_levels_in_position_item_numbers' => 'getSkipNonExistingLevelsInPositionItemNumbers',
        'skipped_tiers_filler' => 'getSkippedTiersFiller',
        'schema_is_correctly_defined' => 'getSchemaIsCorrectlyDefined',
        'allow_upper_case_lettering' => 'getAllowUpperCaseLettering',
        'disable_left_padding_tiers_with_filler' => 'getDisableLeftPaddingTiersWithFiller',
        'disable_item_number_identifier_transformations' => 'getDisableItemNumberIdentifierTransformations',
        'disable_item_number_identifier_transformations_only_for_alphanumeric_tiers' => 'getDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('total_length', $data ?? [], null);
        $this->setIfExists('tiers', $data ?? [], null);
        $this->setIfExists('separator', $data ?? [], null);
        $this->setIfExists('filler', $data ?? [], null);
        $this->setIfExists('identifier', $data ?? [], null);
        $this->setIfExists('skip_non_existing_levels_in_position_item_numbers', $data ?? [], null);
        $this->setIfExists('skipped_tiers_filler', $data ?? [], null);
        $this->setIfExists('schema_is_correctly_defined', $data ?? [], null);
        $this->setIfExists('allow_upper_case_lettering', $data ?? [], null);
        $this->setIfExists('disable_left_padding_tiers_with_filler', $data ?? [], null);
        $this->setIfExists('disable_item_number_identifier_transformations', $data ?? [], null);
        $this->setIfExists('disable_item_number_identifier_transformations_only_for_alphanumeric_tiers', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['total_length'] === null) {
            $invalidProperties[] = "'total_length' can't be null";
        }
        if ($this->container['skip_non_existing_levels_in_position_item_numbers'] === null) {
            $invalidProperties[] = "'skip_non_existing_levels_in_position_item_numbers' can't be null";
        }
        if ($this->container['schema_is_correctly_defined'] === null) {
            $invalidProperties[] = "'schema_is_correctly_defined' can't be null";
        }
        if ($this->container['allow_upper_case_lettering'] === null) {
            $invalidProperties[] = "'allow_upper_case_lettering' can't be null";
        }
        if ($this->container['disable_left_padding_tiers_with_filler'] === null) {
            $invalidProperties[] = "'disable_left_padding_tiers_with_filler' can't be null";
        }
        if ($this->container['disable_item_number_identifier_transformations'] === null) {
            $invalidProperties[] = "'disable_item_number_identifier_transformations' can't be null";
        }
        if ($this->container['disable_item_number_identifier_transformations_only_for_alphanumeric_tiers'] === null) {
            $invalidProperties[] = "'disable_item_number_identifier_transformations_only_for_alphanumeric_tiers' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets total_length
     *
     * @return int
     */
    public function getTotalLength()
    {
        return $this->container['total_length'];
    }

    /**
     * Sets total_length
     *
     * @param int $total_length The count of tiers in the ItemNumberSchema
     *
     * @return self
     */
    public function setTotalLength($total_length)
    {
        if (is_null($total_length)) {
            throw new \InvalidArgumentException('non-nullable total_length cannot be null');
        }
        $this->container['total_length'] = $total_length;

        return $this;
    }

    /**
     * Gets tiers
     *
     * @return \Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]|null
     */
    public function getTiers()
    {
        return $this->container['tiers'];
    }

    /**
     * Sets tiers
     *
     * @param \Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]|null $tiers The collection of tiers for this ItemNumberSchema.
     *
     * @return self
     */
    public function setTiers($tiers)
    {
        if (is_null($tiers)) {
            throw new \InvalidArgumentException('non-nullable tiers cannot be null');
        }
        $this->container['tiers'] = $tiers;

        return $this;
    }

    /**
     * Gets separator
     *
     * @return string|null
     */
    public function getSeparator()
    {
        return $this->container['separator'];
    }

    /**
     * Sets separator
     *
     * @param string|null $separator The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results
     *
     * @return self
     */
    public function setSeparator($separator)
    {
        if (is_null($separator)) {
            throw new \InvalidArgumentException('non-nullable separator cannot be null');
        }
        $this->container['separator'] = $separator;

        return $this;
    }

    /**
     * Gets filler
     *
     * @return string|null
     */
    public function getFiller()
    {
        return $this->container['filler'];
    }

    /**
     * Sets filler
     *
     * @param string|null $filler This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations.
     *
     * @return self
     */
    public function setFiller($filler)
    {
        if (is_null($filler)) {
            throw new \InvalidArgumentException('non-nullable filler cannot be null');
        }
        $this->container['filler'] = $filler;

        return $this;
    }

    /**
     * Gets identifier
     *
     * @return string|null
     */
    public function getIdentifier()
    {
        return $this->container['identifier'];
    }

    /**
     * Sets identifier
     *
     * @param string|null $identifier This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store Ã–Norm service specification structure types.
     *
     * @return self
     */
    public function setIdentifier($identifier)
    {
        if (is_null($identifier)) {
            throw new \InvalidArgumentException('non-nullable identifier cannot be null');
        }
        $this->container['identifier'] = $identifier;

        return $this;
    }

    /**
     * Gets skip_non_existing_levels_in_position_item_numbers
     *
     * @return bool
     */
    public function getSkipNonExistingLevelsInPositionItemNumbers()
    {
        return $this->container['skip_non_existing_levels_in_position_item_numbers'];
    }

    /**
     * Sets skip_non_existing_levels_in_position_item_numbers
     *
     * @param bool $skip_non_existing_levels_in_position_item_numbers This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation.
     *
     * @return self
     */
    public function setSkipNonExistingLevelsInPositionItemNumbers($skip_non_existing_levels_in_position_item_numbers)
    {
        if (is_null($skip_non_existing_levels_in_position_item_numbers)) {
            throw new \InvalidArgumentException('non-nullable skip_non_existing_levels_in_position_item_numbers cannot be null');
        }
        $this->container['skip_non_existing_levels_in_position_item_numbers'] = $skip_non_existing_levels_in_position_item_numbers;

        return $this;
    }

    /**
     * Gets skipped_tiers_filler
     *
     * @return string|null
     */
    public function getSkippedTiersFiller()
    {
        return $this->container['skipped_tiers_filler'];
    }

    /**
     * Sets skipped_tiers_filler
     *
     * @param string|null $skipped_tiers_filler This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations.
     *
     * @return self
     */
    public function setSkippedTiersFiller($skipped_tiers_filler)
    {
        if (is_null($skipped_tiers_filler)) {
            throw new \InvalidArgumentException('non-nullable skipped_tiers_filler cannot be null');
        }
        $this->container['skipped_tiers_filler'] = $skipped_tiers_filler;

        return $this;
    }

    /**
     * Gets schema_is_correctly_defined
     *
     * @return bool
     */
    public function getSchemaIsCorrectlyDefined()
    {
        return $this->container['schema_is_correctly_defined'];
    }

    /**
     * Sets schema_is_correctly_defined
     *
     * @param bool $schema_is_correctly_defined This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false.
     *
     * @return self
     */
    public function setSchemaIsCorrectlyDefined($schema_is_correctly_defined)
    {
        if (is_null($schema_is_correctly_defined)) {
            throw new \InvalidArgumentException('non-nullable schema_is_correctly_defined cannot be null');
        }
        $this->container['schema_is_correctly_defined'] = $schema_is_correctly_defined;

        return $this;
    }

    /**
     * Gets allow_upper_case_lettering
     *
     * @return bool
     */
    public function getAllowUpperCaseLettering()
    {
        return $this->container['allow_upper_case_lettering'];
    }

    /**
     * Sets allow_upper_case_lettering
     *
     * @param bool $allow_upper_case_lettering Defaults to false. If this is disabled, all letters in the ItemNumber string representations will be transformed to their lowercase representation.
     *
     * @return self
     */
    public function setAllowUpperCaseLettering($allow_upper_case_lettering)
    {
        if (is_null($allow_upper_case_lettering)) {
            throw new \InvalidArgumentException('non-nullable allow_upper_case_lettering cannot be null');
        }
        $this->container['allow_upper_case_lettering'] = $allow_upper_case_lettering;

        return $this;
    }

    /**
     * Gets disable_left_padding_tiers_with_filler
     *
     * @return bool
     */
    public function getDisableLeftPaddingTiersWithFiller()
    {
        return $this->container['disable_left_padding_tiers_with_filler'];
    }

    /**
     * Sets disable_left_padding_tiers_with_filler
     *
     * @param bool $disable_left_padding_tiers_with_filler If this is set to true, single identifiers in an item number will not be left padded to fill the length of the tier. This is useful for allowing custom formats in item numbers, without following the GAEB standard. Defaults to false.
     *
     * @return self
     */
    public function setDisableLeftPaddingTiersWithFiller($disable_left_padding_tiers_with_filler)
    {
        if (is_null($disable_left_padding_tiers_with_filler)) {
            throw new \InvalidArgumentException('non-nullable disable_left_padding_tiers_with_filler cannot be null');
        }
        $this->container['disable_left_padding_tiers_with_filler'] = $disable_left_padding_tiers_with_filler;

        return $this;
    }

    /**
     * Gets disable_item_number_identifier_transformations
     *
     * @return bool
     */
    public function getDisableItemNumberIdentifierTransformations()
    {
        return $this->container['disable_item_number_identifier_transformations'];
    }

    /**
     * Sets disable_item_number_identifier_transformations
     *
     * @param bool $disable_item_number_identifier_transformations If this is enabled, then item numbers will not be transformed, except padded. This makes it possible to represent item numbers as-is from e.g. a GAEB file, and also mixing padded and non-padded segments in an item number. This is not recommonded to use by default, since it will lead to inconsistent item numbers in the project.
     *
     * @return self
     */
    public function setDisableItemNumberIdentifierTransformations($disable_item_number_identifier_transformations)
    {
        if (is_null($disable_item_number_identifier_transformations)) {
            throw new \InvalidArgumentException('non-nullable disable_item_number_identifier_transformations cannot be null');
        }
        $this->container['disable_item_number_identifier_transformations'] = $disable_item_number_identifier_transformations;

        return $this;
    }

    /**
     * Gets disable_item_number_identifier_transformations_only_for_alphanumeric_tiers
     *
     * @return bool
     */
    public function getDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers()
    {
        return $this->container['disable_item_number_identifier_transformations_only_for_alphanumeric_tiers'];
    }

    /**
     * Sets disable_item_number_identifier_transformations_only_for_alphanumeric_tiers
     *
     * @param bool $disable_item_number_identifier_transformations_only_for_alphanumeric_tiers This property is used in combination with DisableItemNumberIdentifierTransformations. If this is enabled, then the transformation of item numbers is only disabled for alphanumeric tiers. This means that numeric tiers will still be padded with the filler character, but alphanumeric tiers will not be transformed
     *
     * @return self
     */
    public function setDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers($disable_item_number_identifier_transformations_only_for_alphanumeric_tiers)
    {
        if (is_null($disable_item_number_identifier_transformations_only_for_alphanumeric_tiers)) {
            throw new \InvalidArgumentException('non-nullable disable_item_number_identifier_transformations_only_for_alphanumeric_tiers cannot be null');
        }
        $this->container['disable_item_number_identifier_transformations_only_for_alphanumeric_tiers'] = $disable_item_number_identifier_transformations_only_for_alphanumeric_tiers;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


