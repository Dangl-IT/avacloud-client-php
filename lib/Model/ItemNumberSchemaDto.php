<?php
/**
 * ItemNumberSchemaDto
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AVACloud API 1.64.1
 *
 * AVACloud API specification
 *
 * The version of the OpenAPI document: 1.64.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */


/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Dangl\AVACloud\Model;

use \ArrayAccess;
use \Dangl\AVACloud\ObjectSerializer;

/**
 * ItemNumberSchemaDto Class Doc Comment
 *
 * @category Class
 * @description The schema for ItemNumber&#39;s in a Project.
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ItemNumberSchemaDto implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ItemNumberSchemaDto';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'totalLength' => 'int',
        'tiers' => '\Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]',
        'separator' => 'string',
        'filler' => 'string',
        'identifier' => 'string',
        'skipNonExistingLevelsInPositionItemNumbers' => 'bool',
        'skippedTiersFiller' => 'string',
        'schemaIsCorrectlyDefined' => 'bool',
        'allowUpperCaseLettering' => 'bool',
        'disableLeftPaddingTiersWithFiller' => 'bool',
        'disableItemNumberIdentifierTransformations' => 'bool',
        'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'totalLength' => 'int32',
        'tiers' => null,
        'separator' => null,
        'filler' => null,
        'identifier' => null,
        'skipNonExistingLevelsInPositionItemNumbers' => null,
        'skippedTiersFiller' => null,
        'schemaIsCorrectlyDefined' => null,
        'allowUpperCaseLettering' => null,
        'disableLeftPaddingTiersWithFiller' => null,
        'disableItemNumberIdentifierTransformations' => null,
        'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'totalLength' => false,
        'tiers' => false,
        'separator' => false,
        'filler' => false,
        'identifier' => false,
        'skipNonExistingLevelsInPositionItemNumbers' => false,
        'skippedTiersFiller' => false,
        'schemaIsCorrectlyDefined' => false,
        'allowUpperCaseLettering' => false,
        'disableLeftPaddingTiersWithFiller' => false,
        'disableItemNumberIdentifierTransformations' => false,
        'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'totalLength' => 'totalLength',
        'tiers' => 'tiers',
        'separator' => 'separator',
        'filler' => 'filler',
        'identifier' => 'identifier',
        'skipNonExistingLevelsInPositionItemNumbers' => 'skipNonExistingLevelsInPositionItemNumbers',
        'skippedTiersFiller' => 'skippedTiersFiller',
        'schemaIsCorrectlyDefined' => 'schemaIsCorrectlyDefined',
        'allowUpperCaseLettering' => 'allowUpperCaseLettering',
        'disableLeftPaddingTiersWithFiller' => 'disableLeftPaddingTiersWithFiller',
        'disableItemNumberIdentifierTransformations' => 'disableItemNumberIdentifierTransformations',
        'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers' => 'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'totalLength' => 'setTotalLength',
        'tiers' => 'setTiers',
        'separator' => 'setSeparator',
        'filler' => 'setFiller',
        'identifier' => 'setIdentifier',
        'skipNonExistingLevelsInPositionItemNumbers' => 'setSkipNonExistingLevelsInPositionItemNumbers',
        'skippedTiersFiller' => 'setSkippedTiersFiller',
        'schemaIsCorrectlyDefined' => 'setSchemaIsCorrectlyDefined',
        'allowUpperCaseLettering' => 'setAllowUpperCaseLettering',
        'disableLeftPaddingTiersWithFiller' => 'setDisableLeftPaddingTiersWithFiller',
        'disableItemNumberIdentifierTransformations' => 'setDisableItemNumberIdentifierTransformations',
        'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers' => 'setDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'totalLength' => 'getTotalLength',
        'tiers' => 'getTiers',
        'separator' => 'getSeparator',
        'filler' => 'getFiller',
        'identifier' => 'getIdentifier',
        'skipNonExistingLevelsInPositionItemNumbers' => 'getSkipNonExistingLevelsInPositionItemNumbers',
        'skippedTiersFiller' => 'getSkippedTiersFiller',
        'schemaIsCorrectlyDefined' => 'getSchemaIsCorrectlyDefined',
        'allowUpperCaseLettering' => 'getAllowUpperCaseLettering',
        'disableLeftPaddingTiersWithFiller' => 'getDisableLeftPaddingTiersWithFiller',
        'disableItemNumberIdentifierTransformations' => 'getDisableItemNumberIdentifierTransformations',
        'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers' => 'getDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('totalLength', $data ?? [], null);
        $this->setIfExists('tiers', $data ?? [], null);
        $this->setIfExists('separator', $data ?? [], null);
        $this->setIfExists('filler', $data ?? [], null);
        $this->setIfExists('identifier', $data ?? [], null);
        $this->setIfExists('skipNonExistingLevelsInPositionItemNumbers', $data ?? [], null);
        $this->setIfExists('skippedTiersFiller', $data ?? [], null);
        $this->setIfExists('schemaIsCorrectlyDefined', $data ?? [], null);
        $this->setIfExists('allowUpperCaseLettering', $data ?? [], null);
        $this->setIfExists('disableLeftPaddingTiersWithFiller', $data ?? [], null);
        $this->setIfExists('disableItemNumberIdentifierTransformations', $data ?? [], null);
        $this->setIfExists('disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['totalLength'] === null) {
            $invalidProperties[] = "'totalLength' can't be null";
        }
        if ($this->container['skipNonExistingLevelsInPositionItemNumbers'] === null) {
            $invalidProperties[] = "'skipNonExistingLevelsInPositionItemNumbers' can't be null";
        }
        if ($this->container['schemaIsCorrectlyDefined'] === null) {
            $invalidProperties[] = "'schemaIsCorrectlyDefined' can't be null";
        }
        if ($this->container['allowUpperCaseLettering'] === null) {
            $invalidProperties[] = "'allowUpperCaseLettering' can't be null";
        }
        if ($this->container['disableLeftPaddingTiersWithFiller'] === null) {
            $invalidProperties[] = "'disableLeftPaddingTiersWithFiller' can't be null";
        }
        if ($this->container['disableItemNumberIdentifierTransformations'] === null) {
            $invalidProperties[] = "'disableItemNumberIdentifierTransformations' can't be null";
        }
        if ($this->container['disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'] === null) {
            $invalidProperties[] = "'disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets totalLength
     *
     * @return int
     */
    public function getTotalLength()
    {
        return $this->container['totalLength'];
    }

    /**
     * Sets totalLength
     *
     * @param int $totalLength The count of tiers in the ItemNumberSchema
     *
     * @return self
     */
    public function setTotalLength($totalLength)
    {
        if (is_null($totalLength)) {
            throw new \InvalidArgumentException('non-nullable totalLength cannot be null');
        }
        $this->container['totalLength'] = $totalLength;

        return $this;
    }

    /**
     * Gets tiers
     *
     * @return \Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]|null
     */
    public function getTiers()
    {
        return $this->container['tiers'];
    }

    /**
     * Sets tiers
     *
     * @param \Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]|null $tiers The collection of tiers for this ItemNumberSchema.
     *
     * @return self
     */
    public function setTiers($tiers)
    {
        if (is_null($tiers)) {
            throw new \InvalidArgumentException('non-nullable tiers cannot be null');
        }
        $this->container['tiers'] = $tiers;

        return $this;
    }

    /**
     * Gets separator
     *
     * @return string|null
     */
    public function getSeparator()
    {
        return $this->container['separator'];
    }

    /**
     * Sets separator
     *
     * @param string|null $separator The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results
     *
     * @return self
     */
    public function setSeparator($separator)
    {
        if (is_null($separator)) {
            throw new \InvalidArgumentException('non-nullable separator cannot be null');
        }
        $this->container['separator'] = $separator;

        return $this;
    }

    /**
     * Gets filler
     *
     * @return string|null
     */
    public function getFiller()
    {
        return $this->container['filler'];
    }

    /**
     * Sets filler
     *
     * @param string|null $filler This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations.
     *
     * @return self
     */
    public function setFiller($filler)
    {
        if (is_null($filler)) {
            throw new \InvalidArgumentException('non-nullable filler cannot be null');
        }
        $this->container['filler'] = $filler;

        return $this;
    }

    /**
     * Gets identifier
     *
     * @return string|null
     */
    public function getIdentifier()
    {
        return $this->container['identifier'];
    }

    /**
     * Sets identifier
     *
     * @param string|null $identifier This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store Ã–Norm service specification structure types.
     *
     * @return self
     */
    public function setIdentifier($identifier)
    {
        if (is_null($identifier)) {
            throw new \InvalidArgumentException('non-nullable identifier cannot be null');
        }
        $this->container['identifier'] = $identifier;

        return $this;
    }

    /**
     * Gets skipNonExistingLevelsInPositionItemNumbers
     *
     * @return bool
     */
    public function getSkipNonExistingLevelsInPositionItemNumbers()
    {
        return $this->container['skipNonExistingLevelsInPositionItemNumbers'];
    }

    /**
     * Sets skipNonExistingLevelsInPositionItemNumbers
     *
     * @param bool $skipNonExistingLevelsInPositionItemNumbers This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation.
     *
     * @return self
     */
    public function setSkipNonExistingLevelsInPositionItemNumbers($skipNonExistingLevelsInPositionItemNumbers)
    {
        if (is_null($skipNonExistingLevelsInPositionItemNumbers)) {
            throw new \InvalidArgumentException('non-nullable skipNonExistingLevelsInPositionItemNumbers cannot be null');
        }
        $this->container['skipNonExistingLevelsInPositionItemNumbers'] = $skipNonExistingLevelsInPositionItemNumbers;

        return $this;
    }

    /**
     * Gets skippedTiersFiller
     *
     * @return string|null
     */
    public function getSkippedTiersFiller()
    {
        return $this->container['skippedTiersFiller'];
    }

    /**
     * Sets skippedTiersFiller
     *
     * @param string|null $skippedTiersFiller This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations.
     *
     * @return self
     */
    public function setSkippedTiersFiller($skippedTiersFiller)
    {
        if (is_null($skippedTiersFiller)) {
            throw new \InvalidArgumentException('non-nullable skippedTiersFiller cannot be null');
        }
        $this->container['skippedTiersFiller'] = $skippedTiersFiller;

        return $this;
    }

    /**
     * Gets schemaIsCorrectlyDefined
     *
     * @return bool
     */
    public function getSchemaIsCorrectlyDefined()
    {
        return $this->container['schemaIsCorrectlyDefined'];
    }

    /**
     * Sets schemaIsCorrectlyDefined
     *
     * @param bool $schemaIsCorrectlyDefined This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false.
     *
     * @return self
     */
    public function setSchemaIsCorrectlyDefined($schemaIsCorrectlyDefined)
    {
        if (is_null($schemaIsCorrectlyDefined)) {
            throw new \InvalidArgumentException('non-nullable schemaIsCorrectlyDefined cannot be null');
        }
        $this->container['schemaIsCorrectlyDefined'] = $schemaIsCorrectlyDefined;

        return $this;
    }

    /**
     * Gets allowUpperCaseLettering
     *
     * @return bool
     */
    public function getAllowUpperCaseLettering()
    {
        return $this->container['allowUpperCaseLettering'];
    }

    /**
     * Sets allowUpperCaseLettering
     *
     * @param bool $allowUpperCaseLettering Defaults to false. If this is disabled, all letters in the ItemNumber string representations will be transformed to their lowercase representation.
     *
     * @return self
     */
    public function setAllowUpperCaseLettering($allowUpperCaseLettering)
    {
        if (is_null($allowUpperCaseLettering)) {
            throw new \InvalidArgumentException('non-nullable allowUpperCaseLettering cannot be null');
        }
        $this->container['allowUpperCaseLettering'] = $allowUpperCaseLettering;

        return $this;
    }

    /**
     * Gets disableLeftPaddingTiersWithFiller
     *
     * @return bool
     */
    public function getDisableLeftPaddingTiersWithFiller()
    {
        return $this->container['disableLeftPaddingTiersWithFiller'];
    }

    /**
     * Sets disableLeftPaddingTiersWithFiller
     *
     * @param bool $disableLeftPaddingTiersWithFiller If this is set to true, single identifiers in an item number will not be left padded to fill the length of the tier. This is useful for allowing custom formats in item numbers, without following the GAEB standard. Defaults to false.
     *
     * @return self
     */
    public function setDisableLeftPaddingTiersWithFiller($disableLeftPaddingTiersWithFiller)
    {
        if (is_null($disableLeftPaddingTiersWithFiller)) {
            throw new \InvalidArgumentException('non-nullable disableLeftPaddingTiersWithFiller cannot be null');
        }
        $this->container['disableLeftPaddingTiersWithFiller'] = $disableLeftPaddingTiersWithFiller;

        return $this;
    }

    /**
     * Gets disableItemNumberIdentifierTransformations
     *
     * @return bool
     */
    public function getDisableItemNumberIdentifierTransformations()
    {
        return $this->container['disableItemNumberIdentifierTransformations'];
    }

    /**
     * Sets disableItemNumberIdentifierTransformations
     *
     * @param bool $disableItemNumberIdentifierTransformations If this is enabled, then item numbers will not be transformed, except padded. This makes it possible to represent item numbers as-is from e.g. a GAEB file, and also mixing padded and non-padded segments in an item number. This is not recommonded to use by default, since it will lead to inconsistent item numbers in the project.
     *
     * @return self
     */
    public function setDisableItemNumberIdentifierTransformations($disableItemNumberIdentifierTransformations)
    {
        if (is_null($disableItemNumberIdentifierTransformations)) {
            throw new \InvalidArgumentException('non-nullable disableItemNumberIdentifierTransformations cannot be null');
        }
        $this->container['disableItemNumberIdentifierTransformations'] = $disableItemNumberIdentifierTransformations;

        return $this;
    }

    /**
     * Gets disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers
     *
     * @return bool
     */
    public function getDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers()
    {
        return $this->container['disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'];
    }

    /**
     * Sets disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers
     *
     * @param bool $disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers This property is used in combination with DisableItemNumberIdentifierTransformations. If this is enabled, then the transformation of item numbers is only disabled for alphanumeric tiers. This means that numeric tiers will still be padded with the filler character, but alphanumeric tiers will not be transformed
     *
     * @return self
     */
    public function setDisableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers($disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers)
    {
        if (is_null($disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers)) {
            throw new \InvalidArgumentException('non-nullable disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers cannot be null');
        }
        $this->container['disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers'] = $disableItemNumberIdentifierTransformationsOnlyForAlphanumericTiers;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


