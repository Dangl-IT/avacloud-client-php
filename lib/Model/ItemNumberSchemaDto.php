<?php
/**
 * ItemNumberSchemaDto
 *
 * PHP version 5
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AVACloud API 1.52.1
 *
 * AVACloud API specification
 *
 * OpenAPI spec version: 1.52.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.41
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Dangl\AVACloud\Model;

use \ArrayAccess;
use \Dangl\AVACloud\ObjectSerializer;

/**
 * ItemNumberSchemaDto Class Doc Comment
 *
 * @category Class
 * @description The schema for ItemNumber&#39;s in a Project.
 * @package  Dangl\AVACloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ItemNumberSchemaDto implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ItemNumberSchemaDto';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'total_length' => 'int',
        'tiers' => '\Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]',
        'separator' => 'string',
        'filler' => 'string',
        'identifier' => 'string',
        'skip_non_existing_levels_in_position_item_numbers' => 'bool',
        'skipped_tiers_filler' => 'string',
        'schema_is_correctly_defined' => 'bool',
        'allow_upper_case_lettering' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'total_length' => 'int32',
        'tiers' => null,
        'separator' => null,
        'filler' => null,
        'identifier' => null,
        'skip_non_existing_levels_in_position_item_numbers' => null,
        'skipped_tiers_filler' => null,
        'schema_is_correctly_defined' => null,
        'allow_upper_case_lettering' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'total_length' => 'totalLength',
        'tiers' => 'tiers',
        'separator' => 'separator',
        'filler' => 'filler',
        'identifier' => 'identifier',
        'skip_non_existing_levels_in_position_item_numbers' => 'skipNonExistingLevelsInPositionItemNumbers',
        'skipped_tiers_filler' => 'skippedTiersFiller',
        'schema_is_correctly_defined' => 'schemaIsCorrectlyDefined',
        'allow_upper_case_lettering' => 'allowUpperCaseLettering'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'total_length' => 'setTotalLength',
        'tiers' => 'setTiers',
        'separator' => 'setSeparator',
        'filler' => 'setFiller',
        'identifier' => 'setIdentifier',
        'skip_non_existing_levels_in_position_item_numbers' => 'setSkipNonExistingLevelsInPositionItemNumbers',
        'skipped_tiers_filler' => 'setSkippedTiersFiller',
        'schema_is_correctly_defined' => 'setSchemaIsCorrectlyDefined',
        'allow_upper_case_lettering' => 'setAllowUpperCaseLettering'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'total_length' => 'getTotalLength',
        'tiers' => 'getTiers',
        'separator' => 'getSeparator',
        'filler' => 'getFiller',
        'identifier' => 'getIdentifier',
        'skip_non_existing_levels_in_position_item_numbers' => 'getSkipNonExistingLevelsInPositionItemNumbers',
        'skipped_tiers_filler' => 'getSkippedTiersFiller',
        'schema_is_correctly_defined' => 'getSchemaIsCorrectlyDefined',
        'allow_upper_case_lettering' => 'getAllowUpperCaseLettering'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['total_length'] = isset($data['total_length']) ? $data['total_length'] : null;
        $this->container['tiers'] = isset($data['tiers']) ? $data['tiers'] : null;
        $this->container['separator'] = isset($data['separator']) ? $data['separator'] : null;
        $this->container['filler'] = isset($data['filler']) ? $data['filler'] : null;
        $this->container['identifier'] = isset($data['identifier']) ? $data['identifier'] : null;
        $this->container['skip_non_existing_levels_in_position_item_numbers'] = isset($data['skip_non_existing_levels_in_position_item_numbers']) ? $data['skip_non_existing_levels_in_position_item_numbers'] : null;
        $this->container['skipped_tiers_filler'] = isset($data['skipped_tiers_filler']) ? $data['skipped_tiers_filler'] : null;
        $this->container['schema_is_correctly_defined'] = isset($data['schema_is_correctly_defined']) ? $data['schema_is_correctly_defined'] : null;
        $this->container['allow_upper_case_lettering'] = isset($data['allow_upper_case_lettering']) ? $data['allow_upper_case_lettering'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['total_length'] === null) {
            $invalidProperties[] = "'total_length' can't be null";
        }
        if ($this->container['skip_non_existing_levels_in_position_item_numbers'] === null) {
            $invalidProperties[] = "'skip_non_existing_levels_in_position_item_numbers' can't be null";
        }
        if ($this->container['schema_is_correctly_defined'] === null) {
            $invalidProperties[] = "'schema_is_correctly_defined' can't be null";
        }
        if ($this->container['allow_upper_case_lettering'] === null) {
            $invalidProperties[] = "'allow_upper_case_lettering' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets total_length
     *
     * @return int
     */
    public function getTotalLength()
    {
        return $this->container['total_length'];
    }

    /**
     * Sets total_length
     *
     * @param int $total_length The count of tiers in the ItemNumberSchema
     *
     * @return $this
     */
    public function setTotalLength($total_length)
    {
        $this->container['total_length'] = $total_length;

        return $this;
    }

    /**
     * Gets tiers
     *
     * @return \Dangl\AVACloud\Model\ItemNumberSchemaTierDto[]
     */
    public function getTiers()
    {
        return $this->container['tiers'];
    }

    /**
     * Sets tiers
     *
     * @param \Dangl\AVACloud\Model\ItemNumberSchemaTierDto[] $tiers The collection of tiers for this ItemNumberSchema.
     *
     * @return $this
     */
    public function setTiers($tiers)
    {
        $this->container['tiers'] = $tiers;

        return $this;
    }

    /**
     * Gets separator
     *
     * @return string
     */
    public function getSeparator()
    {
        return $this->container['separator'];
    }

    /**
     * Sets separator
     *
     * @param string $separator The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results
     *
     * @return $this
     */
    public function setSeparator($separator)
    {
        $this->container['separator'] = $separator;

        return $this;
    }

    /**
     * Gets filler
     *
     * @return string
     */
    public function getFiller()
    {
        return $this->container['filler'];
    }

    /**
     * Sets filler
     *
     * @param string $filler This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations.
     *
     * @return $this
     */
    public function setFiller($filler)
    {
        $this->container['filler'] = $filler;

        return $this;
    }

    /**
     * Gets identifier
     *
     * @return string
     */
    public function getIdentifier()
    {
        return $this->container['identifier'];
    }

    /**
     * Sets identifier
     *
     * @param string $identifier This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store ÖNorm service specification structure types.
     *
     * @return $this
     */
    public function setIdentifier($identifier)
    {
        $this->container['identifier'] = $identifier;

        return $this;
    }

    /**
     * Gets skip_non_existing_levels_in_position_item_numbers
     *
     * @return bool
     */
    public function getSkipNonExistingLevelsInPositionItemNumbers()
    {
        return $this->container['skip_non_existing_levels_in_position_item_numbers'];
    }

    /**
     * Sets skip_non_existing_levels_in_position_item_numbers
     *
     * @param bool $skip_non_existing_levels_in_position_item_numbers This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation.
     *
     * @return $this
     */
    public function setSkipNonExistingLevelsInPositionItemNumbers($skip_non_existing_levels_in_position_item_numbers)
    {
        $this->container['skip_non_existing_levels_in_position_item_numbers'] = $skip_non_existing_levels_in_position_item_numbers;

        return $this;
    }

    /**
     * Gets skipped_tiers_filler
     *
     * @return string
     */
    public function getSkippedTiersFiller()
    {
        return $this->container['skipped_tiers_filler'];
    }

    /**
     * Sets skipped_tiers_filler
     *
     * @param string $skipped_tiers_filler This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations.
     *
     * @return $this
     */
    public function setSkippedTiersFiller($skipped_tiers_filler)
    {
        $this->container['skipped_tiers_filler'] = $skipped_tiers_filler;

        return $this;
    }

    /**
     * Gets schema_is_correctly_defined
     *
     * @return bool
     */
    public function getSchemaIsCorrectlyDefined()
    {
        return $this->container['schema_is_correctly_defined'];
    }

    /**
     * Sets schema_is_correctly_defined
     *
     * @param bool $schema_is_correctly_defined This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false.
     *
     * @return $this
     */
    public function setSchemaIsCorrectlyDefined($schema_is_correctly_defined)
    {
        $this->container['schema_is_correctly_defined'] = $schema_is_correctly_defined;

        return $this;
    }

    /**
     * Gets allow_upper_case_lettering
     *
     * @return bool
     */
    public function getAllowUpperCaseLettering()
    {
        return $this->container['allow_upper_case_lettering'];
    }

    /**
     * Sets allow_upper_case_lettering
     *
     * @param bool $allow_upper_case_lettering Defaults to false. If this is disabled, all letters in the ItemNumber string representations will be transformed to their lowercase representation.
     *
     * @return $this
     */
    public function setAllowUpperCaseLettering($allow_upper_case_lettering)
    {
        $this->container['allow_upper_case_lettering'] = $allow_upper_case_lettering;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


