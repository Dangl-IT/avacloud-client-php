<?php
/**
 * AvaProjectWrapper
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AVACloud API 1.64.1
 *
 * AVACloud API specification
 *
 * The version of the OpenAPI document: 1.64.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */


/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Dangl\AVACloud\Model;

use \ArrayAccess;
use \Dangl\AVACloud\ObjectSerializer;

/**
 * AvaProjectWrapper Class Doc Comment
 *
 * @category Class
 * @description This is a wrapper class that maps Dangl.AVA projects along with additional required information to create invoices
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class AvaProjectWrapper implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'AvaProjectWrapper';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'project' => '\Dangl\AVACloud\Model\ProjectDto',
        'invoice_number' => 'string',
        'documents' => '\Dangl\AVACloud\Model\SupportingDocument[]',
        'invoice_period' => '\Dangl\AVACloud\Model\InvoicePeriod',
        'payment_instructions' => '\Dangl\AVACloud\Model\PaymentInstructions',
        'invoice_type' => '\Dangl\AVACloud\Model\InvoiceType',
        'is_eu_reverse_charge_invoice' => 'bool',
        'payment_due_date' => '\DateTime',
        'payment_terms' => 'string',
        'previous_invoices' => '\Dangl\AVACloud\Model\PreviousInvoice[]',
        'already_paid_total_gross' => 'float',
        'references' => '\Dangl\AVACloud\Model\References',
        'allowances' => '\Dangl\AVACloud\Model\InvoiceAllowance[]',
        'charges' => '\Dangl\AVACloud\Model\InvoiceCharge[]',
        'delivery_information' => '\Dangl\AVACloud\Model\DeliveryInformation',
        'seller_tax_representative' => '\Dangl\AVACloud\Model\Organization'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'project' => null,
        'invoice_number' => null,
        'documents' => null,
        'invoice_period' => null,
        'payment_instructions' => null,
        'invoice_type' => null,
        'is_eu_reverse_charge_invoice' => null,
        'payment_due_date' => 'date-time',
        'payment_terms' => null,
        'previous_invoices' => null,
        'already_paid_total_gross' => 'decimal',
        'references' => null,
        'allowances' => null,
        'charges' => null,
        'delivery_information' => null,
        'seller_tax_representative' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'project' => false,
        'invoice_number' => false,
        'documents' => false,
        'invoice_period' => false,
        'payment_instructions' => false,
        'invoice_type' => false,
        'is_eu_reverse_charge_invoice' => false,
        'payment_due_date' => false,
        'payment_terms' => false,
        'previous_invoices' => false,
        'already_paid_total_gross' => false,
        'references' => false,
        'allowances' => false,
        'charges' => false,
        'delivery_information' => false,
        'seller_tax_representative' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'project' => 'project',
        'invoice_number' => 'invoiceNumber',
        'documents' => 'documents',
        'invoice_period' => 'invoicePeriod',
        'payment_instructions' => 'paymentInstructions',
        'invoice_type' => 'invoiceType',
        'is_eu_reverse_charge_invoice' => 'isEuReverseChargeInvoice',
        'payment_due_date' => 'paymentDueDate',
        'payment_terms' => 'paymentTerms',
        'previous_invoices' => 'previousInvoices',
        'already_paid_total_gross' => 'alreadyPaidTotalGross',
        'references' => 'references',
        'allowances' => 'allowances',
        'charges' => 'charges',
        'delivery_information' => 'deliveryInformation',
        'seller_tax_representative' => 'sellerTaxRepresentative'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'project' => 'setProject',
        'invoice_number' => 'setInvoiceNumber',
        'documents' => 'setDocuments',
        'invoice_period' => 'setInvoicePeriod',
        'payment_instructions' => 'setPaymentInstructions',
        'invoice_type' => 'setInvoiceType',
        'is_eu_reverse_charge_invoice' => 'setIsEuReverseChargeInvoice',
        'payment_due_date' => 'setPaymentDueDate',
        'payment_terms' => 'setPaymentTerms',
        'previous_invoices' => 'setPreviousInvoices',
        'already_paid_total_gross' => 'setAlreadyPaidTotalGross',
        'references' => 'setReferences',
        'allowances' => 'setAllowances',
        'charges' => 'setCharges',
        'delivery_information' => 'setDeliveryInformation',
        'seller_tax_representative' => 'setSellerTaxRepresentative'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'project' => 'getProject',
        'invoice_number' => 'getInvoiceNumber',
        'documents' => 'getDocuments',
        'invoice_period' => 'getInvoicePeriod',
        'payment_instructions' => 'getPaymentInstructions',
        'invoice_type' => 'getInvoiceType',
        'is_eu_reverse_charge_invoice' => 'getIsEuReverseChargeInvoice',
        'payment_due_date' => 'getPaymentDueDate',
        'payment_terms' => 'getPaymentTerms',
        'previous_invoices' => 'getPreviousInvoices',
        'already_paid_total_gross' => 'getAlreadyPaidTotalGross',
        'references' => 'getReferences',
        'allowances' => 'getAllowances',
        'charges' => 'getCharges',
        'delivery_information' => 'getDeliveryInformation',
        'seller_tax_representative' => 'getSellerTaxRepresentative'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('project', $data ?? [], null);
        $this->setIfExists('invoice_number', $data ?? [], null);
        $this->setIfExists('documents', $data ?? [], null);
        $this->setIfExists('invoice_period', $data ?? [], null);
        $this->setIfExists('payment_instructions', $data ?? [], null);
        $this->setIfExists('invoice_type', $data ?? [], null);
        $this->setIfExists('is_eu_reverse_charge_invoice', $data ?? [], null);
        $this->setIfExists('payment_due_date', $data ?? [], null);
        $this->setIfExists('payment_terms', $data ?? [], null);
        $this->setIfExists('previous_invoices', $data ?? [], null);
        $this->setIfExists('already_paid_total_gross', $data ?? [], null);
        $this->setIfExists('references', $data ?? [], null);
        $this->setIfExists('allowances', $data ?? [], null);
        $this->setIfExists('charges', $data ?? [], null);
        $this->setIfExists('delivery_information', $data ?? [], null);
        $this->setIfExists('seller_tax_representative', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['project'] === null) {
            $invalidProperties[] = "'project' can't be null";
        }
        if ($this->container['invoice_type'] === null) {
            $invalidProperties[] = "'invoice_type' can't be null";
        }
        if ($this->container['is_eu_reverse_charge_invoice'] === null) {
            $invalidProperties[] = "'is_eu_reverse_charge_invoice' can't be null";
        }
        if ($this->container['already_paid_total_gross'] === null) {
            $invalidProperties[] = "'already_paid_total_gross' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets project
     *
     * @return \Dangl\AVACloud\Model\ProjectDto
     */
    public function getProject()
    {
        return $this->container['project'];
    }

    /**
     * Sets project
     *
     * @param \Dangl\AVACloud\Model\ProjectDto $project project
     *
     * @return self
     */
    public function setProject($project)
    {
        if (is_null($project)) {
            throw new \InvalidArgumentException('non-nullable project cannot be null');
        }
        $this->container['project'] = $project;

        return $this;
    }

    /**
     * Gets invoice_number
     *
     * @return string|null
     */
    public function getInvoiceNumber()
    {
        return $this->container['invoice_number'];
    }

    /**
     * Sets invoice_number
     *
     * @param string|null $invoice_number The number of the invoice
     *
     * @return self
     */
    public function setInvoiceNumber($invoice_number)
    {
        if (is_null($invoice_number)) {
            throw new \InvalidArgumentException('non-nullable invoice_number cannot be null');
        }
        $this->container['invoice_number'] = $invoice_number;

        return $this;
    }

    /**
     * Gets documents
     *
     * @return \Dangl\AVACloud\Model\SupportingDocument[]|null
     */
    public function getDocuments()
    {
        return $this->container['documents'];
    }

    /**
     * Sets documents
     *
     * @param \Dangl\AVACloud\Model\SupportingDocument[]|null $documents Attached documents to the invoice
     *
     * @return self
     */
    public function setDocuments($documents)
    {
        if (is_null($documents)) {
            throw new \InvalidArgumentException('non-nullable documents cannot be null');
        }
        $this->container['documents'] = $documents;

        return $this;
    }

    /**
     * Gets invoice_period
     *
     * @return \Dangl\AVACloud\Model\InvoicePeriod|null
     */
    public function getInvoicePeriod()
    {
        return $this->container['invoice_period'];
    }

    /**
     * Sets invoice_period
     *
     * @param \Dangl\AVACloud\Model\InvoicePeriod|null $invoice_period invoice_period
     *
     * @return self
     */
    public function setInvoicePeriod($invoice_period)
    {
        if (is_null($invoice_period)) {
            throw new \InvalidArgumentException('non-nullable invoice_period cannot be null');
        }
        $this->container['invoice_period'] = $invoice_period;

        return $this;
    }

    /**
     * Gets payment_instructions
     *
     * @return \Dangl\AVACloud\Model\PaymentInstructions|null
     */
    public function getPaymentInstructions()
    {
        return $this->container['payment_instructions'];
    }

    /**
     * Sets payment_instructions
     *
     * @param \Dangl\AVACloud\Model\PaymentInstructions|null $payment_instructions payment_instructions
     *
     * @return self
     */
    public function setPaymentInstructions($payment_instructions)
    {
        if (is_null($payment_instructions)) {
            throw new \InvalidArgumentException('non-nullable payment_instructions cannot be null');
        }
        $this->container['payment_instructions'] = $payment_instructions;

        return $this;
    }

    /**
     * Gets invoice_type
     *
     * @return \Dangl\AVACloud\Model\InvoiceType
     */
    public function getInvoiceType()
    {
        return $this->container['invoice_type'];
    }

    /**
     * Sets invoice_type
     *
     * @param \Dangl\AVACloud\Model\InvoiceType $invoice_type invoice_type
     *
     * @return self
     */
    public function setInvoiceType($invoice_type)
    {
        if (is_null($invoice_type)) {
            throw new \InvalidArgumentException('non-nullable invoice_type cannot be null');
        }
        $this->container['invoice_type'] = $invoice_type;

        return $this;
    }

    /**
     * Gets is_eu_reverse_charge_invoice
     *
     * @return bool
     */
    public function getIsEuReverseChargeInvoice()
    {
        return $this->container['is_eu_reverse_charge_invoice'];
    }

    /**
     * Sets is_eu_reverse_charge_invoice
     *
     * @param bool $is_eu_reverse_charge_invoice If this is set to true, the invoice will be marked as a reverse charge invoice in all VAT rates. You still need to ensure that the actual tax rates are set to zero in all elements
     *
     * @return self
     */
    public function setIsEuReverseChargeInvoice($is_eu_reverse_charge_invoice)
    {
        if (is_null($is_eu_reverse_charge_invoice)) {
            throw new \InvalidArgumentException('non-nullable is_eu_reverse_charge_invoice cannot be null');
        }
        $this->container['is_eu_reverse_charge_invoice'] = $is_eu_reverse_charge_invoice;

        return $this;
    }

    /**
     * Gets payment_due_date
     *
     * @return \DateTime|null
     */
    public function getPaymentDueDate()
    {
        return $this->container['payment_due_date'];
    }

    /**
     * Sets payment_due_date
     *
     * @param \DateTime|null $payment_due_date Until when the payment is due
     *
     * @return self
     */
    public function setPaymentDueDate($payment_due_date)
    {
        if (is_null($payment_due_date)) {
            throw new \InvalidArgumentException('non-nullable payment_due_date cannot be null');
        }
        $this->container['payment_due_date'] = $payment_due_date;

        return $this;
    }

    /**
     * Gets payment_terms
     *
     * @return string|null
     */
    public function getPaymentTerms()
    {
        return $this->container['payment_terms'];
    }

    /**
     * Sets payment_terms
     *
     * @param string|null $payment_terms A text description of payment terms, e.g. cash discounts or payment conditions
     *
     * @return self
     */
    public function setPaymentTerms($payment_terms)
    {
        if (is_null($payment_terms)) {
            throw new \InvalidArgumentException('non-nullable payment_terms cannot be null');
        }
        $this->container['payment_terms'] = $payment_terms;

        return $this;
    }

    /**
     * Gets previous_invoices
     *
     * @return \Dangl\AVACloud\Model\PreviousInvoice[]|null
     */
    public function getPreviousInvoices()
    {
        return $this->container['previous_invoices'];
    }

    /**
     * Sets previous_invoices
     *
     * @param \Dangl\AVACloud\Model\PreviousInvoice[]|null $previous_invoices In case of partial of final invoices, it's possible to reference the previous invoice numbers
     *
     * @return self
     */
    public function setPreviousInvoices($previous_invoices)
    {
        if (is_null($previous_invoices)) {
            throw new \InvalidArgumentException('non-nullable previous_invoices cannot be null');
        }
        $this->container['previous_invoices'] = $previous_invoices;

        return $this;
    }

    /**
     * Gets already_paid_total_gross
     *
     * @return float
     */
    public function getAlreadyPaidTotalGross()
    {
        return $this->container['already_paid_total_gross'];
    }

    /**
     * Sets already_paid_total_gross
     *
     * @param float $already_paid_total_gross If parts of this invoice (or of previous invoices) have already been paid, then this property can be used to specify that some parts of the invoice are already paid and this will be deducted from the to be paid amount.
     *
     * @return self
     */
    public function setAlreadyPaidTotalGross($already_paid_total_gross)
    {
        if (is_null($already_paid_total_gross)) {
            throw new \InvalidArgumentException('non-nullable already_paid_total_gross cannot be null');
        }
        $this->container['already_paid_total_gross'] = $already_paid_total_gross;

        return $this;
    }

    /**
     * Gets references
     *
     * @return \Dangl\AVACloud\Model\References|null
     */
    public function getReferences()
    {
        return $this->container['references'];
    }

    /**
     * Sets references
     *
     * @param \Dangl\AVACloud\Model\References|null $references references
     *
     * @return self
     */
    public function setReferences($references)
    {
        if (is_null($references)) {
            throw new \InvalidArgumentException('non-nullable references cannot be null');
        }
        $this->container['references'] = $references;

        return $this;
    }

    /**
     * Gets allowances
     *
     * @return \Dangl\AVACloud\Model\InvoiceAllowance[]|null
     */
    public function getAllowances()
    {
        return $this->container['allowances'];
    }

    /**
     * Sets allowances
     *
     * @param \Dangl\AVACloud\Model\InvoiceAllowance[]|null $allowances Optional document level allowances. For example, those can be used to supply global discounts e.g. for security deposits. When using this property, please pay attention that a deduction factor on the exported ServiceSpecification will also be exported as an allowance, in this case the total price of the invoice might be different from the total price of the ServiceSpecification.
     *
     * @return self
     */
    public function setAllowances($allowances)
    {
        if (is_null($allowances)) {
            throw new \InvalidArgumentException('non-nullable allowances cannot be null');
        }
        $this->container['allowances'] = $allowances;

        return $this;
    }

    /**
     * Gets charges
     *
     * @return \Dangl\AVACloud\Model\InvoiceCharge[]|null
     */
    public function getCharges()
    {
        return $this->container['charges'];
    }

    /**
     * Sets charges
     *
     * @param \Dangl\AVACloud\Model\InvoiceCharge[]|null $charges Optional document level charges, e.g. for shipping or handling. When using this property, please pay attention that the charges given here will be applied to the already calculated total price of the ServiceSpecification, in this case the total price of the invoice might be different from the total price of the ServiceSpecification.
     *
     * @return self
     */
    public function setCharges($charges)
    {
        if (is_null($charges)) {
            throw new \InvalidArgumentException('non-nullable charges cannot be null');
        }
        $this->container['charges'] = $charges;

        return $this;
    }

    /**
     * Gets delivery_information
     *
     * @return \Dangl\AVACloud\Model\DeliveryInformation|null
     */
    public function getDeliveryInformation()
    {
        return $this->container['delivery_information'];
    }

    /**
     * Sets delivery_information
     *
     * @param \Dangl\AVACloud\Model\DeliveryInformation|null $delivery_information delivery_information
     *
     * @return self
     */
    public function setDeliveryInformation($delivery_information)
    {
        if (is_null($delivery_information)) {
            throw new \InvalidArgumentException('non-nullable delivery_information cannot be null');
        }
        $this->container['delivery_information'] = $delivery_information;

        return $this;
    }

    /**
     * Gets seller_tax_representative
     *
     * @return \Dangl\AVACloud\Model\Organization|null
     */
    public function getSellerTaxRepresentative()
    {
        return $this->container['seller_tax_representative'];
    }

    /**
     * Sets seller_tax_representative
     *
     * @param \Dangl\AVACloud\Model\Organization|null $seller_tax_representative seller_tax_representative
     *
     * @return self
     */
    public function setSellerTaxRepresentative($seller_tax_representative)
    {
        if (is_null($seller_tax_representative)) {
            throw new \InvalidArgumentException('non-nullable seller_tax_representative cannot be null');
        }
        $this->container['seller_tax_representative'] = $seller_tax_representative;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


