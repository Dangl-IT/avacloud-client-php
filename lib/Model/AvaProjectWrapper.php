<?php
/**
 * AvaProjectWrapper
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AVACloud API 1.64.1
 *
 * AVACloud API specification
 *
 * The version of the OpenAPI document: 1.64.1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */


/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Dangl\AVACloud\Model;

use \ArrayAccess;
use \Dangl\AVACloud\ObjectSerializer;

/**
 * AvaProjectWrapper Class Doc Comment
 *
 * @category Class
 * @description This is a wrapper class that maps Dangl.AVA projects along with additional required information to create invoices
 * @package  Dangl\AVACloud
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class AvaProjectWrapper implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'AvaProjectWrapper';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'project' => '\Dangl\AVACloud\Model\ProjectDto',
        'invoiceNumber' => 'string',
        'documents' => '\Dangl\AVACloud\Model\SupportingDocument[]',
        'invoicePeriod' => '\Dangl\AVACloud\Model\InvoicePeriod',
        'paymentInstructions' => '\Dangl\AVACloud\Model\PaymentInstructions',
        'invoiceType' => '\Dangl\AVACloud\Model\InvoiceType',
        'isEuReverseChargeInvoice' => 'bool',
        'paymentDueDate' => '\DateTime',
        'paymentTerms' => 'string',
        'previousInvoices' => '\Dangl\AVACloud\Model\PreviousInvoice[]',
        'alreadyPaidTotalGross' => 'float',
        'references' => '\Dangl\AVACloud\Model\References',
        'allowances' => '\Dangl\AVACloud\Model\InvoiceAllowance[]',
        'charges' => '\Dangl\AVACloud\Model\InvoiceCharge[]',
        'deliveryInformation' => '\Dangl\AVACloud\Model\DeliveryInformation',
        'sellerTaxRepresentative' => '\Dangl\AVACloud\Model\Organization'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'project' => null,
        'invoiceNumber' => null,
        'documents' => null,
        'invoicePeriod' => null,
        'paymentInstructions' => null,
        'invoiceType' => null,
        'isEuReverseChargeInvoice' => null,
        'paymentDueDate' => 'date-time',
        'paymentTerms' => null,
        'previousInvoices' => null,
        'alreadyPaidTotalGross' => 'decimal',
        'references' => null,
        'allowances' => null,
        'charges' => null,
        'deliveryInformation' => null,
        'sellerTaxRepresentative' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'project' => false,
        'invoiceNumber' => false,
        'documents' => false,
        'invoicePeriod' => false,
        'paymentInstructions' => false,
        'invoiceType' => false,
        'isEuReverseChargeInvoice' => false,
        'paymentDueDate' => false,
        'paymentTerms' => false,
        'previousInvoices' => false,
        'alreadyPaidTotalGross' => false,
        'references' => false,
        'allowances' => false,
        'charges' => false,
        'deliveryInformation' => false,
        'sellerTaxRepresentative' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'project' => 'project',
        'invoiceNumber' => 'invoiceNumber',
        'documents' => 'documents',
        'invoicePeriod' => 'invoicePeriod',
        'paymentInstructions' => 'paymentInstructions',
        'invoiceType' => 'invoiceType',
        'isEuReverseChargeInvoice' => 'isEuReverseChargeInvoice',
        'paymentDueDate' => 'paymentDueDate',
        'paymentTerms' => 'paymentTerms',
        'previousInvoices' => 'previousInvoices',
        'alreadyPaidTotalGross' => 'alreadyPaidTotalGross',
        'references' => 'references',
        'allowances' => 'allowances',
        'charges' => 'charges',
        'deliveryInformation' => 'deliveryInformation',
        'sellerTaxRepresentative' => 'sellerTaxRepresentative'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'project' => 'setProject',
        'invoiceNumber' => 'setInvoiceNumber',
        'documents' => 'setDocuments',
        'invoicePeriod' => 'setInvoicePeriod',
        'paymentInstructions' => 'setPaymentInstructions',
        'invoiceType' => 'setInvoiceType',
        'isEuReverseChargeInvoice' => 'setIsEuReverseChargeInvoice',
        'paymentDueDate' => 'setPaymentDueDate',
        'paymentTerms' => 'setPaymentTerms',
        'previousInvoices' => 'setPreviousInvoices',
        'alreadyPaidTotalGross' => 'setAlreadyPaidTotalGross',
        'references' => 'setReferences',
        'allowances' => 'setAllowances',
        'charges' => 'setCharges',
        'deliveryInformation' => 'setDeliveryInformation',
        'sellerTaxRepresentative' => 'setSellerTaxRepresentative'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'project' => 'getProject',
        'invoiceNumber' => 'getInvoiceNumber',
        'documents' => 'getDocuments',
        'invoicePeriod' => 'getInvoicePeriod',
        'paymentInstructions' => 'getPaymentInstructions',
        'invoiceType' => 'getInvoiceType',
        'isEuReverseChargeInvoice' => 'getIsEuReverseChargeInvoice',
        'paymentDueDate' => 'getPaymentDueDate',
        'paymentTerms' => 'getPaymentTerms',
        'previousInvoices' => 'getPreviousInvoices',
        'alreadyPaidTotalGross' => 'getAlreadyPaidTotalGross',
        'references' => 'getReferences',
        'allowances' => 'getAllowances',
        'charges' => 'getCharges',
        'deliveryInformation' => 'getDeliveryInformation',
        'sellerTaxRepresentative' => 'getSellerTaxRepresentative'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('project', $data ?? [], null);
        $this->setIfExists('invoiceNumber', $data ?? [], null);
        $this->setIfExists('documents', $data ?? [], null);
        $this->setIfExists('invoicePeriod', $data ?? [], null);
        $this->setIfExists('paymentInstructions', $data ?? [], null);
        $this->setIfExists('invoiceType', $data ?? [], null);
        $this->setIfExists('isEuReverseChargeInvoice', $data ?? [], null);
        $this->setIfExists('paymentDueDate', $data ?? [], null);
        $this->setIfExists('paymentTerms', $data ?? [], null);
        $this->setIfExists('previousInvoices', $data ?? [], null);
        $this->setIfExists('alreadyPaidTotalGross', $data ?? [], null);
        $this->setIfExists('references', $data ?? [], null);
        $this->setIfExists('allowances', $data ?? [], null);
        $this->setIfExists('charges', $data ?? [], null);
        $this->setIfExists('deliveryInformation', $data ?? [], null);
        $this->setIfExists('sellerTaxRepresentative', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['project'] === null) {
            $invalidProperties[] = "'project' can't be null";
        }
        if ($this->container['invoiceType'] === null) {
            $invalidProperties[] = "'invoiceType' can't be null";
        }
        if ($this->container['isEuReverseChargeInvoice'] === null) {
            $invalidProperties[] = "'isEuReverseChargeInvoice' can't be null";
        }
        if ($this->container['alreadyPaidTotalGross'] === null) {
            $invalidProperties[] = "'alreadyPaidTotalGross' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets project
     *
     * @return \Dangl\AVACloud\Model\ProjectDto
     */
    public function getProject()
    {
        return $this->container['project'];
    }

    /**
     * Sets project
     *
     * @param \Dangl\AVACloud\Model\ProjectDto $project project
     *
     * @return self
     */
    public function setProject($project)
    {
        if (is_null($project)) {
            throw new \InvalidArgumentException('non-nullable project cannot be null');
        }
        $this->container['project'] = $project;

        return $this;
    }

    /**
     * Gets invoiceNumber
     *
     * @return string|null
     */
    public function getInvoiceNumber()
    {
        return $this->container['invoiceNumber'];
    }

    /**
     * Sets invoiceNumber
     *
     * @param string|null $invoiceNumber The number of the invoice
     *
     * @return self
     */
    public function setInvoiceNumber($invoiceNumber)
    {
        if (is_null($invoiceNumber)) {
            throw new \InvalidArgumentException('non-nullable invoiceNumber cannot be null');
        }
        $this->container['invoiceNumber'] = $invoiceNumber;

        return $this;
    }

    /**
     * Gets documents
     *
     * @return \Dangl\AVACloud\Model\SupportingDocument[]|null
     */
    public function getDocuments()
    {
        return $this->container['documents'];
    }

    /**
     * Sets documents
     *
     * @param \Dangl\AVACloud\Model\SupportingDocument[]|null $documents Attached documents to the invoice
     *
     * @return self
     */
    public function setDocuments($documents)
    {
        if (is_null($documents)) {
            throw new \InvalidArgumentException('non-nullable documents cannot be null');
        }
        $this->container['documents'] = $documents;

        return $this;
    }

    /**
     * Gets invoicePeriod
     *
     * @return \Dangl\AVACloud\Model\InvoicePeriod|null
     */
    public function getInvoicePeriod()
    {
        return $this->container['invoicePeriod'];
    }

    /**
     * Sets invoicePeriod
     *
     * @param \Dangl\AVACloud\Model\InvoicePeriod|null $invoicePeriod invoicePeriod
     *
     * @return self
     */
    public function setInvoicePeriod($invoicePeriod)
    {
        if (is_null($invoicePeriod)) {
            throw new \InvalidArgumentException('non-nullable invoicePeriod cannot be null');
        }
        $this->container['invoicePeriod'] = $invoicePeriod;

        return $this;
    }

    /**
     * Gets paymentInstructions
     *
     * @return \Dangl\AVACloud\Model\PaymentInstructions|null
     */
    public function getPaymentInstructions()
    {
        return $this->container['paymentInstructions'];
    }

    /**
     * Sets paymentInstructions
     *
     * @param \Dangl\AVACloud\Model\PaymentInstructions|null $paymentInstructions paymentInstructions
     *
     * @return self
     */
    public function setPaymentInstructions($paymentInstructions)
    {
        if (is_null($paymentInstructions)) {
            throw new \InvalidArgumentException('non-nullable paymentInstructions cannot be null');
        }
        $this->container['paymentInstructions'] = $paymentInstructions;

        return $this;
    }

    /**
     * Gets invoiceType
     *
     * @return \Dangl\AVACloud\Model\InvoiceType
     */
    public function getInvoiceType()
    {
        return $this->container['invoiceType'];
    }

    /**
     * Sets invoiceType
     *
     * @param \Dangl\AVACloud\Model\InvoiceType $invoiceType invoiceType
     *
     * @return self
     */
    public function setInvoiceType($invoiceType)
    {
        if (is_null($invoiceType)) {
            throw new \InvalidArgumentException('non-nullable invoiceType cannot be null');
        }
        $this->container['invoiceType'] = $invoiceType;

        return $this;
    }

    /**
     * Gets isEuReverseChargeInvoice
     *
     * @return bool
     */
    public function getIsEuReverseChargeInvoice()
    {
        return $this->container['isEuReverseChargeInvoice'];
    }

    /**
     * Sets isEuReverseChargeInvoice
     *
     * @param bool $isEuReverseChargeInvoice If this is set to true, the invoice will be marked as a reverse charge invoice in all VAT rates. You still need to ensure that the actual tax rates are set to zero in all elements
     *
     * @return self
     */
    public function setIsEuReverseChargeInvoice($isEuReverseChargeInvoice)
    {
        if (is_null($isEuReverseChargeInvoice)) {
            throw new \InvalidArgumentException('non-nullable isEuReverseChargeInvoice cannot be null');
        }
        $this->container['isEuReverseChargeInvoice'] = $isEuReverseChargeInvoice;

        return $this;
    }

    /**
     * Gets paymentDueDate
     *
     * @return \DateTime|null
     */
    public function getPaymentDueDate()
    {
        return $this->container['paymentDueDate'];
    }

    /**
     * Sets paymentDueDate
     *
     * @param \DateTime|null $paymentDueDate Until when the payment is due
     *
     * @return self
     */
    public function setPaymentDueDate($paymentDueDate)
    {
        if (is_null($paymentDueDate)) {
            throw new \InvalidArgumentException('non-nullable paymentDueDate cannot be null');
        }
        $this->container['paymentDueDate'] = $paymentDueDate;

        return $this;
    }

    /**
     * Gets paymentTerms
     *
     * @return string|null
     */
    public function getPaymentTerms()
    {
        return $this->container['paymentTerms'];
    }

    /**
     * Sets paymentTerms
     *
     * @param string|null $paymentTerms A text description of payment terms, e.g. cash discounts or payment conditions
     *
     * @return self
     */
    public function setPaymentTerms($paymentTerms)
    {
        if (is_null($paymentTerms)) {
            throw new \InvalidArgumentException('non-nullable paymentTerms cannot be null');
        }
        $this->container['paymentTerms'] = $paymentTerms;

        return $this;
    }

    /**
     * Gets previousInvoices
     *
     * @return \Dangl\AVACloud\Model\PreviousInvoice[]|null
     */
    public function getPreviousInvoices()
    {
        return $this->container['previousInvoices'];
    }

    /**
     * Sets previousInvoices
     *
     * @param \Dangl\AVACloud\Model\PreviousInvoice[]|null $previousInvoices In case of partial of final invoices, it's possible to reference the previous invoice numbers
     *
     * @return self
     */
    public function setPreviousInvoices($previousInvoices)
    {
        if (is_null($previousInvoices)) {
            throw new \InvalidArgumentException('non-nullable previousInvoices cannot be null');
        }
        $this->container['previousInvoices'] = $previousInvoices;

        return $this;
    }

    /**
     * Gets alreadyPaidTotalGross
     *
     * @return float
     */
    public function getAlreadyPaidTotalGross()
    {
        return $this->container['alreadyPaidTotalGross'];
    }

    /**
     * Sets alreadyPaidTotalGross
     *
     * @param float $alreadyPaidTotalGross If parts of this invoice (or of previous invoices) have already been paid, then this property can be used to specify that some parts of the invoice are already paid and this will be deducted from the to be paid amount.
     *
     * @return self
     */
    public function setAlreadyPaidTotalGross($alreadyPaidTotalGross)
    {
        if (is_null($alreadyPaidTotalGross)) {
            throw new \InvalidArgumentException('non-nullable alreadyPaidTotalGross cannot be null');
        }
        $this->container['alreadyPaidTotalGross'] = $alreadyPaidTotalGross;

        return $this;
    }

    /**
     * Gets references
     *
     * @return \Dangl\AVACloud\Model\References|null
     */
    public function getReferences()
    {
        return $this->container['references'];
    }

    /**
     * Sets references
     *
     * @param \Dangl\AVACloud\Model\References|null $references references
     *
     * @return self
     */
    public function setReferences($references)
    {
        if (is_null($references)) {
            throw new \InvalidArgumentException('non-nullable references cannot be null');
        }
        $this->container['references'] = $references;

        return $this;
    }

    /**
     * Gets allowances
     *
     * @return \Dangl\AVACloud\Model\InvoiceAllowance[]|null
     */
    public function getAllowances()
    {
        return $this->container['allowances'];
    }

    /**
     * Sets allowances
     *
     * @param \Dangl\AVACloud\Model\InvoiceAllowance[]|null $allowances Optional document level allowances. For example, those can be used to supply global discounts e.g. for security deposits. When using this property, please pay attention that a deduction factor on the exported ServiceSpecification will also be exported as an allowance, in this case the total price of the invoice might be different from the total price of the ServiceSpecification.
     *
     * @return self
     */
    public function setAllowances($allowances)
    {
        if (is_null($allowances)) {
            throw new \InvalidArgumentException('non-nullable allowances cannot be null');
        }
        $this->container['allowances'] = $allowances;

        return $this;
    }

    /**
     * Gets charges
     *
     * @return \Dangl\AVACloud\Model\InvoiceCharge[]|null
     */
    public function getCharges()
    {
        return $this->container['charges'];
    }

    /**
     * Sets charges
     *
     * @param \Dangl\AVACloud\Model\InvoiceCharge[]|null $charges Optional document level charges, e.g. for shipping or handling. When using this property, please pay attention that the charges given here will be applied to the already calculated total price of the ServiceSpecification, in this case the total price of the invoice might be different from the total price of the ServiceSpecification.
     *
     * @return self
     */
    public function setCharges($charges)
    {
        if (is_null($charges)) {
            throw new \InvalidArgumentException('non-nullable charges cannot be null');
        }
        $this->container['charges'] = $charges;

        return $this;
    }

    /**
     * Gets deliveryInformation
     *
     * @return \Dangl\AVACloud\Model\DeliveryInformation|null
     */
    public function getDeliveryInformation()
    {
        return $this->container['deliveryInformation'];
    }

    /**
     * Sets deliveryInformation
     *
     * @param \Dangl\AVACloud\Model\DeliveryInformation|null $deliveryInformation deliveryInformation
     *
     * @return self
     */
    public function setDeliveryInformation($deliveryInformation)
    {
        if (is_null($deliveryInformation)) {
            throw new \InvalidArgumentException('non-nullable deliveryInformation cannot be null');
        }
        $this->container['deliveryInformation'] = $deliveryInformation;

        return $this;
    }

    /**
     * Gets sellerTaxRepresentative
     *
     * @return \Dangl\AVACloud\Model\Organization|null
     */
    public function getSellerTaxRepresentative()
    {
        return $this->container['sellerTaxRepresentative'];
    }

    /**
     * Sets sellerTaxRepresentative
     *
     * @param \Dangl\AVACloud\Model\Organization|null $sellerTaxRepresentative sellerTaxRepresentative
     *
     * @return self
     */
    public function setSellerTaxRepresentative($sellerTaxRepresentative)
    {
        if (is_null($sellerTaxRepresentative)) {
            throw new \InvalidArgumentException('non-nullable sellerTaxRepresentative cannot be null');
        }
        $this->container['sellerTaxRepresentative'] = $sellerTaxRepresentative;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


