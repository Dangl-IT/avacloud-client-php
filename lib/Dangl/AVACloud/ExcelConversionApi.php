<?php
/**
 * ExcelConversionApi
 * PHP version 5
 *
 * @category Class
 * @package  Dangl/AVACloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AVACloud API 1.9.1
 *
 * AVACloud API specification
 *
 * OpenAPI spec version: 1.9.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Dangl/AVACloud\Dangl\AVACloud;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Dangl/AVACloud\ApiException;
use Dangl/AVACloud\Configuration;
use Dangl/AVACloud\HeaderSelector;
use Dangl/AVACloud\ObjectSerializer;

/**
 * ExcelConversionApi Class Doc Comment
 *
 * @category Class
 * @package  Dangl/AVACloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ExcelConversionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation excelConversionConvertToAva
     *
     * Converts Excel files to Dangl.AVA projects.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Dangl/AVACloud\Dangl\AVACloud\ProjectDto
     */
    public function excelConversionConvertToAva($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        list($response) = $this->excelConversionConvertToAvaWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $remove_plain_text_long_texts, $remove_html_long_texts);
        return $response;
    }

    /**
     * Operation excelConversionConvertToAvaWithHttpInfo
     *
     * Converts Excel files to Dangl.AVA projects.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Dangl/AVACloud\Dangl\AVACloud\ProjectDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function excelConversionConvertToAvaWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        $returnType = '\Dangl/AVACloud\Dangl\AVACloud\ProjectDto';
        $request = $this->excelConversionConvertToAvaRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $remove_plain_text_long_texts, $remove_html_long_texts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl/AVACloud\Dangl\AVACloud\ProjectDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl/AVACloud\Dangl\AVACloud\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation excelConversionConvertToAvaAsync
     *
     * Converts Excel files to Dangl.AVA projects.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToAvaAsync($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        return $this->excelConversionConvertToAvaAsyncWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $remove_plain_text_long_texts, $remove_html_long_texts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation excelConversionConvertToAvaAsyncWithHttpInfo
     *
     * Converts Excel files to Dangl.AVA projects.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToAvaAsyncWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {
        $returnType = '\Dangl/AVACloud\Dangl\AVACloud\ProjectDto';
        $request = $this->excelConversionConvertToAvaRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $remove_plain_text_long_texts, $remove_html_long_texts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'excelConversionConvertToAva'
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $remove_plain_text_long_texts If set to true, plain text long texts will be removed from the output to reduce response sizes (optional)
     * @param  bool $remove_html_long_texts If set to true, html long texts will be removed from the output to reduce response sizes (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function excelConversionConvertToAvaRequest($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $remove_plain_text_long_texts = null, $remove_html_long_texts = null)
    {

        $resourcePath = '/conversion/excel/ava';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($read_new_elements !== null) {
            $queryParams['ReadNewElements'] = ObjectSerializer::toQueryValue($read_new_elements);
        }
        // query params
        if ($rebuild_item_number_schema !== null) {
            $queryParams['RebuildItemNumberSchema'] = ObjectSerializer::toQueryValue($rebuild_item_number_schema);
        }
        // query params
        if ($remove_plain_text_long_texts !== null) {
            $queryParams['RemovePlainTextLongTexts'] = ObjectSerializer::toQueryValue($remove_plain_text_long_texts);
        }
        // query params
        if ($remove_html_long_texts !== null) {
            $queryParams['RemoveHtmlLongTexts'] = ObjectSerializer::toQueryValue($remove_html_long_texts);
        }


        // form params
        if ($excel_file !== null) {
            $multipart = true;
            $formParams['excelFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($excel_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/vnd.com.dangl-it.ProjectDto.v1+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/vnd.com.dangl-it.ProjectDto.v1+json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation excelConversionConvertToExcel
     *
     * Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function excelConversionConvertToExcel($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        list($response) = $this->excelConversionConvertToExcelWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $write_prices, $write_long_texts, $conversion_culture);
        return $response;
    }

    /**
     * Operation excelConversionConvertToExcelWithHttpInfo
     *
     * Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function excelConversionConvertToExcelWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->excelConversionConvertToExcelRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $write_prices, $write_long_texts, $conversion_culture);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl/AVACloud\Dangl\AVACloud\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation excelConversionConvertToExcelAsync
     *
     * Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToExcelAsync($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        return $this->excelConversionConvertToExcelAsyncWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $write_prices, $write_long_texts, $conversion_culture)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation excelConversionConvertToExcelAsyncWithHttpInfo
     *
     * Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToExcelAsyncWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->excelConversionConvertToExcelRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $write_prices, $write_long_texts, $conversion_culture);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'excelConversionConvertToExcel'
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  bool $write_prices Defaults to true (optional)
     * @param  bool $write_long_texts Defaults to true (optional)
     * @param  string $conversion_culture The culture that should be used for the conversion process, to have localized Excel files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function excelConversionConvertToExcelRequest($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $write_prices = null, $write_long_texts = null, $conversion_culture = null)
    {

        $resourcePath = '/conversion/excel/excel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($read_new_elements !== null) {
            $queryParams['ReadNewElements'] = ObjectSerializer::toQueryValue($read_new_elements);
        }
        // query params
        if ($rebuild_item_number_schema !== null) {
            $queryParams['RebuildItemNumberSchema'] = ObjectSerializer::toQueryValue($rebuild_item_number_schema);
        }
        // query params
        if ($write_prices !== null) {
            $queryParams['WritePrices'] = ObjectSerializer::toQueryValue($write_prices);
        }
        // query params
        if ($write_long_texts !== null) {
            $queryParams['WriteLongTexts'] = ObjectSerializer::toQueryValue($write_long_texts);
        }
        // query params
        if ($conversion_culture !== null) {
            $queryParams['ConversionCulture'] = ObjectSerializer::toQueryValue($conversion_culture);
        }


        // form params
        if ($excel_file !== null) {
            $multipart = true;
            $formParams['excelFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($excel_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation excelConversionConvertToGaeb
     *
     * Converts Excel files to GAEB files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function excelConversionConvertToGaeb($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        list($response) = $this->excelConversionConvertToGaebWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_gaeb_type, $target_exchange_phase_transform);
        return $response;
    }

    /**
     * Operation excelConversionConvertToGaebWithHttpInfo
     *
     * Converts Excel files to GAEB files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function excelConversionConvertToGaebWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->excelConversionConvertToGaebRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_gaeb_type, $target_exchange_phase_transform);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl/AVACloud\Dangl\AVACloud\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation excelConversionConvertToGaebAsync
     *
     * Converts Excel files to GAEB files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToGaebAsync($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        return $this->excelConversionConvertToGaebAsyncWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_gaeb_type, $target_exchange_phase_transform)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation excelConversionConvertToGaebAsyncWithHttpInfo
     *
     * Converts Excel files to GAEB files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToGaebAsyncWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->excelConversionConvertToGaebRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_gaeb_type, $target_exchange_phase_transform);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'excelConversionConvertToGaeb'
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_gaeb_type Defaults to GAEB XML V3.2 (optional)
     * @param  string $target_exchange_phase_transform Defaults to none, meaning no transformation will be done (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function excelConversionConvertToGaebRequest($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_gaeb_type = null, $target_exchange_phase_transform = null)
    {

        $resourcePath = '/conversion/excel/gaeb';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($read_new_elements !== null) {
            $queryParams['ReadNewElements'] = ObjectSerializer::toQueryValue($read_new_elements);
        }
        // query params
        if ($rebuild_item_number_schema !== null) {
            $queryParams['RebuildItemNumberSchema'] = ObjectSerializer::toQueryValue($rebuild_item_number_schema);
        }
        // query params
        if ($destination_gaeb_type !== null) {
            $queryParams['DestinationGaebType'] = ObjectSerializer::toQueryValue($destination_gaeb_type);
        }
        // query params
        if ($target_exchange_phase_transform !== null) {
            $queryParams['TargetExchangePhaseTransform'] = ObjectSerializer::toQueryValue($target_exchange_phase_transform);
        }


        // form params
        if ($excel_file !== null) {
            $multipart = true;
            $formParams['excelFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($excel_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation excelConversionConvertToOenorm
     *
     * Converts Excel files to Oenorm files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function excelConversionConvertToOenorm($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        list($response) = $this->excelConversionConvertToOenormWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_oenorm_type, $try_repair_project_structure);
        return $response;
    }

    /**
     * Operation excelConversionConvertToOenormWithHttpInfo
     *
     * Converts Excel files to Oenorm files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \Dangl/AVACloud\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function excelConversionConvertToOenormWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->excelConversionConvertToOenormRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_oenorm_type, $try_repair_project_structure);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dangl/AVACloud\Dangl\AVACloud\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation excelConversionConvertToOenormAsync
     *
     * Converts Excel files to Oenorm files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToOenormAsync($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        return $this->excelConversionConvertToOenormAsyncWithHttpInfo($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_oenorm_type, $try_repair_project_structure)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation excelConversionConvertToOenormAsyncWithHttpInfo
     *
     * Converts Excel files to Oenorm files.
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function excelConversionConvertToOenormAsyncWithHttpInfo($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {
        $returnType = '\SplFileObject';
        $request = $this->excelConversionConvertToOenormRequest($excel_file, $read_new_elements, $rebuild_item_number_schema, $destination_oenorm_type, $try_repair_project_structure);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'excelConversionConvertToOenorm'
     *
     * @param  \SplFileObject $excel_file The input file (optional)
     * @param  bool $read_new_elements Defaults to false (optional)
     * @param  bool $rebuild_item_number_schema When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false. (optional)
     * @param  string $destination_oenorm_type Defaults to Lv2015 (optional)
     * @param  bool $try_repair_project_structure Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function excelConversionConvertToOenormRequest($excel_file = null, $read_new_elements = null, $rebuild_item_number_schema = null, $destination_oenorm_type = null, $try_repair_project_structure = null)
    {

        $resourcePath = '/conversion/excel/oenorm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($read_new_elements !== null) {
            $queryParams['ReadNewElements'] = ObjectSerializer::toQueryValue($read_new_elements);
        }
        // query params
        if ($rebuild_item_number_schema !== null) {
            $queryParams['RebuildItemNumberSchema'] = ObjectSerializer::toQueryValue($rebuild_item_number_schema);
        }
        // query params
        if ($destination_oenorm_type !== null) {
            $queryParams['DestinationOenormType'] = ObjectSerializer::toQueryValue($destination_oenorm_type);
        }
        // query params
        if ($try_repair_project_structure !== null) {
            $queryParams['TryRepairProjectStructure'] = ObjectSerializer::toQueryValue($try_repair_project_structure);
        }


        // form params
        if ($excel_file !== null) {
            $multipart = true;
            $formParams['excelFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($excel_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
